/*
 * This file is part of Nooj. Copyright (C) 2012 Silberztein Max
 * 
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with this program. If not, see
 * <http://www.gnu.org/licenses/>.
 */
package net.nooj4nlp.engine;

import java.awt.Color;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.swing.JOptionPane;

import net.nooj4nlp.engine.helper.ParameterCheck;
import net.nooj4nlp.gui.main.Launcher;

import org.apache.commons.io.FilenameUtils;

import Nooj.WoxGrammar;

@SuppressWarnings({ "rawtypes", "unchecked" })
/**
 * 
 * @author Silberztein Max
 *
 */
public class Grammar implements Serializable
{
	/**
	 * 
	 */
	private static final long serialVersionUID = 2937834300602472387L;

	public ArrayList graphs; // list of graphs
	transient public HashMap grams; // (string) name => (Gram) compiled graph
	transient public String fullName; // only used for graph drawing and error messages during lexical/syntactic
										// analysis
	transient private Engine engine; // only used for graph drawing and error messages during lexical/syntactic analysis
	transient private boolean isTextual;

	public int windowHeight = 0, windowWidth = 0;
	public GramType gramType = net.nooj4nlp.engine.GramType.forValue(0);;
	public String author;
	public String institution;
	public int lockType;
	public String checkText = null;
	public String iLanguage, oLanguage; // input/output language

	transient private Language iLan; // default input language (used for lots of matching functions to avoid recreating
										// a new Lan from ILanguage)
	private ArrayList extraParams; // for the future

	public String iFontName;
	public float iFontSize;
	// Sinisa:
	// C#: System.Drawing.FontStyle -> Java: java.awt.Font.style
	public int iFontStyle;
	public String oFontName;
	public float oFontSize;
	public int oFontStyle;
	public String cFontName;
	public float cFontSize;
	public int cFontStyle;

	public Color cColor;
	public Color aColor, bColor, fColor, sColor, vColor; // auxiliary/background/Comment/Frame/Selection/Variable
															// node color
	public boolean dispFrame; // display frame or not
	public boolean dispFile; // display file name
	public boolean dispDir; // display file name
	public boolean dispDate; // display last modification date
	public boolean dispBox = false; // display a box for each node
	public boolean dispState = false; // display circles (true) or arrows (false) for <E> nodes
	public boolean dispAuthor = false; // display Author
	public boolean dispInstitution = false; // display Institution
	public boolean dispGrid = false;

	public static boolean isItTextual(String filePath)
	{
		ParameterCheck.mandatoryString("filePath", filePath);

		BufferedReader reader = null;
		String firstLine;

		try
		{
			reader = new BufferedReader(new FileReader(filePath));

			// read header and get language
			firstLine = reader.readLine();
		}
		catch (FileNotFoundException e)
		{
			e.printStackTrace();
			return false;
		}
		catch (IOException e)
		{
			e.printStackTrace();
			return false;
		}
		finally
		{
			if (reader != null)
			{
				try
				{
					reader.close();
				}
				catch (IOException e)
				{
					JOptionPane.showMessageDialog(Launcher.getDesktopPane(),
							Constants.ERROR_MESSAGE_TITLE_CLOSE_READER_FILE, Constants.NOOJ_ERROR,
							JOptionPane.ERROR_MESSAGE);
				}
			}
		}

		return (firstLine.length() == 9 && firstLine.substring(0, 6).equals("# NooJ"));
	}

	// Constructors

	public Grammar()
	{
		this.graphs = new ArrayList();
		this.grams = new HashMap();
	}

	Grammar(Language ilan, GramType gt, Engine eng)
	{
		this.iLan = ilan;
		this.gramType = gt;
		this.engine = eng;
	}

	// Sinisa:
	// C# optional parameters are not converted to Java:
	// ORIGINAL LINE: internal Grammar (GramType gt,string author,string institution,string password,short
	// locktype,string ilanguage,string olanguage,Preferences preferences = null)
	// Implemented as two constructors

	public Grammar(GramType gt, String author, String institution, String password, int locktype, String ilanguage,
			String olanguage, Preferences preferences)
	{
		this.gramType = gt;
		this.author = author;
		this.institution = institution;
		this.lockType = locktype;
		this.iLanguage = ilanguage;
		this.iLan = new Language(iLanguage);
		this.oLanguage = olanguage;
		this.graphs = new ArrayList();
		this.grams = null;

		if (preferences != null) // could be null if called from tokenizer
		{
			this.iFontName = preferences.IFont.getName();
			this.iFontSize = preferences.IFont.getSize2D();
			this.iFontStyle = preferences.IFont.getStyle();

			this.oFontName = preferences.OFont.getName();
			this.oFontSize = preferences.OFont.getSize2D();
			this.oFontStyle = preferences.OFont.getStyle();

			this.cFontName = preferences.CFont.getName();
			this.cFontSize = preferences.CFont.getSize2D();
			this.cFontStyle = preferences.CFont.getStyle();

			this.aColor = preferences.AColor;
			this.bColor = preferences.BColor;
			this.cColor = preferences.CColor;
			this.fColor = preferences.FColor;
			this.sColor = preferences.SColor;
			this.vColor = preferences.VColor;

			this.dispFrame = preferences.DispFrame;
			this.dispFile = preferences.DispFile;
			this.dispDir = preferences.DispDir;
			this.dispDate = preferences.DispDate;
		}
	}

	// Sinisa: Unused constructor - commented out
	// public Grammar(SerializationInfo info, StreamingContext context)
	// {
	// WindowHeight = info.GetInt32 ("WindowHeight");
	// }

	// Import INTEX Graphs

	public static Grammar importWithAllEmbeddedGraphs(String fullname, GramType gt, String ilanguage, String olanguage,
			int encodingcode, Preferences preferences)
	{
		Grammar grm = new Grammar(gt, null, null, null, 0, ilanguage, olanguage, preferences);
		grm.fullName = fullname;
		Graph grf = Graph.loadIntex(grm, fullname, encodingcode, gt);
		if (grf == null)
		{
			return null;
		}

		grf.wholeGrammar = grm;
		grf.name = FilenameUtils.removeExtension(fullname);
		grm.graphs.add(grf);
		ArrayList recGraph = (ArrayList) new ArrayList();
		recGraph.add(grf.name);

		File f = new File(fullname);
		String dname = f.getParentFile().getAbsolutePath();
		if (!grm.importEmbeddedGraphs(dname, grf, recGraph, encodingcode, gt))
		{
			return null;
		}
		grm.gramType = gt;
		return grm;
	}

	public final boolean importEmbeddedGraphs(String dname, Graph grf, ArrayList recGraph, int encodingcode, GramType gt)
	{
		// import all embedded graphs
		int nbofnodes = grf.label.size();
		ArrayList embeddedGraphs = new ArrayList();
		for (int inode = 0; inode < nbofnodes; inode++)
		{
			if (inode == 1)
			{
				continue;
			}
			if (grf.commentNode(inode) || grf.areaNode(inode))
			{
				continue;
			}
			ArrayList child = (ArrayList) grf.child.get(inode);
			if (child.isEmpty())
			{
				continue;
			}

			String output = null;
			RefObject<String> tempRef_output = new RefObject<String>(output);
			String[] terms = Graph.inLineLabel((String) grf.label.get(inode), tempRef_output);
			output = tempRef_output.argvalue;
			for (int iterm = 0; iterm < terms.length; iterm++)
			{
				if (terms[iterm].length() > 1 && terms[iterm].charAt(0) == ':')
				{
					String gname = terms[iterm].substring(1);
					int index = embeddedGraphs.indexOf(gname);
					if (index != -1) // already present in this graph
					{
						continue;
					}
					embeddedGraphs.add(gname);
					index = recGraph.indexOf(gname);
					if (index != -1) // (recursive call) already present among the ancestors
					{
						continue;
					}
					recGraph.add(gname);
					index = -1;
					Graph grf2;
					for (int ig = 0; ig < graphs.size(); ig++)
					{
						grf2 = (Graph) graphs.get(ig);
						if (grf2 != null && grf2.name.equals(gname))
						{
							index = ig;
							break;
						}
					}
					if (index != -1) // already present in the grammar
					{
						continue;
					}
					File targetFile = new File(dname, gname + ".grf");
					String fullgname = targetFile.getPath();
					if (!targetFile.isFile())
					{

					}
					else
					{
						grf2 = Graph.loadIntex(this, fullgname, encodingcode, gt);
						if (grf2 == null)
						{

						}
						else
						{
							if (!importEmbeddedGraphs(dname, grf2, recGraph, encodingcode, gt))
							{
								return false;
							}
							graphs.add(grf2);
						}
					}
				}
			}
		}
		return true;
	}

	// Serialization

	private final void getDataFromSerialization()
	{
		// Method body commented because it has no any function

		// if (ExtraParams == null)
		// {
		// return;
		// }
		// for (int i = 0; i < ExtraParams.size();)
		// {
		// if (((String) ExtraParams.get(i)).equals("Foobar"))
		// {
		// }
		// }
	}

	private final void storeDataForSerialization()
	{
		extraParams = null; // NooJ V1
	}

	public static Grammar loadTextual(String fullname, GramType gt, RefObject<String> errmessage)
	{
		Grammar grammar = null;

		errmessage.argvalue = null;
		String ilanguagename = null, olanguagename = null;
		RefObject<String> tempRef_ilanguagename = new RefObject<String>(ilanguagename);
		RefObject<String> tempRef_olanguagename = new RefObject<String>(olanguagename);

		Regexps rs = Regexps.load(fullname, errmessage, tempRef_ilanguagename, tempRef_olanguagename);
		ilanguagename = tempRef_ilanguagename.argvalue;
		olanguagename = tempRef_olanguagename.argvalue;
		if (rs == null)
		{
			errmessage.argvalue = "Invalid statements:\n" + errmessage.argvalue;
			Dic.writeLog(errmessage.argvalue);
			return null;
		}

		if (rs.grammar.grams.isEmpty())
		{
			errmessage.argvalue = "Grammar is empty: " + errmessage.argvalue;
			Dic.writeLog(errmessage.argvalue);
			return null;
		}
		Gram grm;

		Set<String> keySet = rs.grammar.grams.keySet();
		for (String expname : keySet)
		{
			grm = (Gram) rs.grammar.grams.get(expname);
			if (grm == null)
			{
				errmessage.argvalue = "Error in grammar rule " + expname;
				Dic.writeLog(errmessage.argvalue);
				return null;
			}
			if (grm.vocabIn == null)
			{
				grm.prepareForParsing();
			}
		}
		grammar = rs.grammar;
		if (grammar != null)
		{
			grammar.gramType = gt;
			grammar.isTextual = true;
			grammar.iLanguage = ilanguagename;
			grammar.iLan = new Language(ilanguagename);
			grammar.oLanguage = olanguagename;
		}
		return grammar;
	}

	public static Grammar loadGraphical(String fullname, boolean fromCSharp)
	{
		Grammar gram = null;
		FileInputStream fs = null;
		if (!fromCSharp)
		{
			try
			{
				fs = new FileInputStream(fullname);
				ObjectInputStream serializer = new ObjectInputStream(fs);
				gram = (Grammar) serializer.readObject();
				serializer.close();
			}
			catch (Exception e)
			{
				if (fs != null)
				{
					try
					{
						fs.close();
					}
					catch (IOException e1)
					{
					}
				}
				System.out.println("Grammar.Load Exception: " + e.getMessage());
				return null;
			}
		}
		else
		{
			WoxGrammar tmp = (WoxGrammar) wox.serial.Easy.load(fullname);
			gram = tmp.toGrammar();
		}

		if (gram == null)
		{
			return null;
		}
		gram.getDataFromSerialization();
		gram.fullName = fullname;

		for (int i = 0; i < gram.graphs.size();)
		{
			Graph grf = (Graph) gram.graphs.get(i);
			if (grf == null || grf.name == null || grf.name.equals(""))
			{
				gram.graphs.remove(i);
			}
			else
			{
				grf.getDataFromSerialization(gram);
				i++;
			}
		}

		// Correct IsoName
		Language ILan = new Language(gram.iLanguage);
		if (ILan != null)
		{
			if (!gram.iLanguage.equals(ILan.isoName)) // e.g. "Fran�ais" instead of "fr"
			{
				gram.iLanguage = ILan.isoName;
			}
		}
		gram.iLan = ILan;
		Language OLan = new Language(gram.oLanguage);
		if (OLan != null)
		{
			if (!gram.oLanguage.equals(OLan.isoName)) // e.g. "Fran�ais" instead of "fr"
			{
				gram.oLanguage = OLan.isoName;
			}
		}
		gram.isTextual = false;
		return gram;
	}

	public final void save(String fullname)
	{
		this.fullName = fullname;
		// serialization
		storeDataForSerialization();
		for (int i = 0; i < graphs.size();)
		{
			Graph grf = (Graph) graphs.get(i);
			if (grf == null || grf.name == null || grf.name.equals(""))
			{
				graphs.remove(i);
			}
			else
			{
				grf.storeDataForSerialization0();
				i++;
			}
		}
		FileOutputStream fs = null;
		try
		{

			File file = new File(fullname);
			// Check if the directory path exists - if not, create it
			String path = file.getAbsolutePath().substring(0, file.getAbsolutePath().lastIndexOf(File.separator));
			File filePath = new File(path);
			if (!filePath.exists())
			{
				filePath.mkdirs();
			}
			fs = new FileOutputStream(fullname);
			ObjectOutputStream serializer = new ObjectOutputStream(fs);
			serializer.writeObject(this);
			serializer.close();
		}
		catch (Exception e)
		{
			if (fs != null)
			{
				try
				{
					fs.close();
				}
				catch (IOException e1)
				{
				}
			}
		}
	}

	// Parsing Initialization Compilation ComputeFirst GetVariableDefinition

	private String compileAllGraphical(Engine eng, boolean computefirst)
	{
		grams = new HashMap();
		Language Lan = new Language(iLanguage);

		this.engine = eng;

		boolean maingrf = false;
		for (int ig = 0; ig < graphs.size(); ig++)
		{
			Graph grf = (Graph) graphs.get(ig);
			if (grf != null && grf.name != null && !grf.name.equals(""))
			{
				if (grf != null && grf.name.equals("Main"))
				{
					maingrf = true;
				}
			}
			grf.wholeGrammar = this;
			ArrayList aVocab = new ArrayList();
			aVocab.add("<E>");
			HashMap hVocab = new HashMap();
			hVocab.put("<E>", 0);
			Gram grm = grf.compile(Lan, gramType, aVocab, hVocab, this.engine);
			if (grm != null)
			{
				grm.vocab = aVocab;
				hVocab = null;
				grm.prepareForParsing();
				if (grams.containsKey(grf.name))
				{
					continue;
				}
				else
				{
					grams.put(grf.name, grm);
				}
			}
		}
		if (computefirst)
		{
			if (!maingrf)
			{
				return "Grammar has no main graph";
			}
			Gram grm = (Gram) grams.get("Main");
			// grm.GFirst = new GrammarFirst (grm.nullable (this));
			grm.computeFirst(this.engine, this);

			if (grm.gFirst.first == null)
			{
			}
		}
		return null;
	}

	private String compileAllTextual(Engine eng, boolean computefirst)
	{
		this.engine = eng;

		boolean maingrf = false;

		Set<String> keySet = this.grams.keySet();
		for (String expname : keySet)
		{
			if (expname.equals("Main"))
			{
				maingrf = true;
			}
			Gram grm = (Gram) this.grams.get(expname);
			if (grm == null)
			{
				return ("Error in rule " + expname);
			}
			if (grm.vocabIn == null)
			{
				grm.prepareForParsing();
			}
		}
		if (computefirst)
		{
			if (!maingrf)
			{
				return "Grammar has no main graph";
			}
			Gram grm = (Gram) grams.get("Main");
			grm.computeFirst(this.engine, this);

			if (grm.gFirst.first == null)
			{
			}
		}
		return null;
	}

	final String addGrams(Grammar cgrammar)
	{
		Set<String> keySet = cgrammar.grams.keySet();
		for (String expname : keySet)
		{
			Gram grm = (Gram) cgrammar.grams.get(expname);
			if (this.grams.containsKey(expname))
			{
				return "Paradigm " + expname + " is defined more than once.";
			}
			this.grams.put(expname, grm);
		}
		return null;
	}

	public final String compileAndComputeFirst(Engine eng, boolean computefirst)
	{
		if (this.isTextual)
		{
			return compileAllTextual(eng, computefirst);
		}
		else
		{
			return compileAllGraphical(eng, computefirst);
		}
	}

	transient private static String epsilon; // "<E>"
	transient private static ArrayList lepsilon; // {"<E>"}
	transient private static ArrayList lnull; // {null}
	transient private static ArrayList l0; // {0}
	transient private static ArrayList l1; // {1}
	transient private static HashMap hlemmas; // lemmas expansion

	private static void setConstants()
	{
		// several constants
		epsilon = "<E>";
		lepsilon = new ArrayList();
		lepsilon.add(epsilon);
		lnull = new ArrayList();
		lnull.add(null);
		l0 = new ArrayList();
		l0.add(0);
		l1 = new ArrayList();
		l1.add(1);

		// various initializations
		hlemmas = null;
	}

	// Morphological Parsing

	private StringBuilder getValue(String varname, ArrayList input, int ipos)
	{
		// scan the input to get the value of the variable
		int index = -1;
		for (int iinput = ipos; iinput >= 0; iinput--)
		{
			// look for $(varname
			String si = (String) input.get(iinput);
			if (si == null || si.length() == 0)
			{
				continue;
			}
			if (si.equals("$(" + varname))
			{
				index = iinput;
				break;
			}
		}
		if (index == -1)
		{
			return null;
		}

		StringBuilder res = new StringBuilder();

		// look for corresponding $)
		int reclevel = 0;
		String sj = null;
		for (int jinput = index + 1; jinput < input.size(); jinput++)
		{
			sj = (String) input.get(jinput);
			if (sj == null || sj.length() == 0)
			{
				continue;
			}
			if (sj.length() >= 2 && sj.charAt(0) == '$' && sj.charAt(1) == '(')
			{
				reclevel++;
				continue;
			}
			else if (sj.length() >= 2 && sj.charAt(0) == '$' && sj.charAt(1) == ')')
			{
				if (reclevel == 0)
				{
					break;
				}
				reclevel--;
			}
			else
			{
				res.append(sj);
			}
		}
		if (sj.length() > 2)
		{
			res = new StringBuilder(sj.substring(2));
		}
		return res;
	}

	private final StringBuilder processVariablesInOutputs(ArrayList input, ArrayList output)
	{
		StringBuilder result = new StringBuilder();
		for (int ipos = 0; ipos < output.size(); ipos++)
		{
			String so = (String) output.get(ipos);
			if (so == null || so.equals(""))
			{
				continue;
			}

			// replace all variable calls in output with their content found in input
			StringBuilder res = new StringBuilder();
			for (int i = 0; i < so.length();)
			{
				if (so.charAt(i) == '\\')
				{
					res.append(so.charAt(i));
					res.append(so.charAt(i + 1));
					i += 2;
					continue;
				}
				else if (so.charAt(i) != '$')
				{
					res.append(so.charAt(i));
					i++;
					continue;
				}

				// get variable name
				int j;
				for (i++, j = 0; i + j < so.length() && !Character.isWhitespace(so.charAt(i + j))
						&& so.charAt(i + j) != '#' && so.charAt(i + j) != '=' && so.charAt(i + j) != '+'
						&& so.charAt(i + j) != ',' && so.charAt(i + j) != '$' && so.charAt(i + j) != '>'
						&& so.charAt(i + j) != '}'; j++)
				{
					;
				}
				String varname = so.toString().substring(i, i + j);
				if (i + j < so.length() && so.charAt(i + j) == '#')
				{
					j++;
				}

				StringBuilder val = getValue(varname, input, ipos);
				if (val == null)
				{
					res.append("$" + varname);
				}
				else
				{
					res.append(val);
				}
				i += j;
			}
			// get rid of all '#'
			for (int i = 0; i < res.length(); i++)
			{
				if (res.charAt(i) != '#')
				{
					result.append(res.charAt(i));
				}
			}
		}
		return result;
	}

	private boolean morphoMatchTermLabel(String ilabel, String token, int ipos, RefObject<Integer> length)
	{
		length.argvalue = 0;
		if (ilabel.equals("<E>"))
		{
			return true;
		}
		if (ilabel.charAt(0) == '$'
				&& ((ilabel.length() > 2 && ilabel.charAt(1) == '(') || (ilabel.length() >= 2 && ilabel.charAt(1) == ')')))
		{
			return true;
		}
		if (ipos >= token.length())
		{
			return false;
		}
		boolean match = false;
		if (ilabel.charAt(0) == '<')
		{
			// C# TO JAVA CONVERTER NOTE: The following 'switch' operated on a string member and was converted to Java
			// 'if-else' logic:
			// switch (ilabel)
			// ORIGINAL LINE: case "<L>":
			if (ilabel.equals("<L>")) // any letter
			{
				match = Language.isLetter(token.charAt(ipos));
			}
			// ORIGINAL LINE: case "<U>":
			else if (ilabel.equals("<U>")) // uppercase letter
			{
				match = Character.isUpperCase(token.charAt(ipos));
			}
			// ORIGINAL LINE: case "<W>":
			else if (ilabel.equals("<W>")) // lowercase letter
			{
				match = Character.isLowerCase(token.charAt(ipos));
			}
			// ORIGINAL LINE: case "<A>":
			else if (ilabel.equals("<A>")) // accented letter
			{
				match = Language.isAccented(token.charAt(ipos));
			}
			// ORIGINAL LINE: case "<N>":
			else if (ilabel.equals("<N>")) // unaccented letter
			{
				match = !Language.isAccented(token.charAt(ipos));
			}
			// ORIGINAL LINE: case "<C>":
			else if (ilabel.equals("<C>")) // consonantic letter
			{
				match = !Language.isVowel(token.charAt(ipos));
			}
			// ORIGINAL LINE: case "<V>":
			else if (ilabel.equals("<V>")) // vowel letter
			{
				match = Language.isVowel(token.charAt(ipos));
			}
			else
			// TODO: each language should be able to add their own symbols
			{
			}
			length.argvalue = 1;
			return match;
		}
		else if (ilabel.charAt(0) == '"') // protected string
		{
			for (int i = 1; i < ilabel.length() - 1; i++)
			{
				if (token.charAt(ipos + i - 1) != ilabel.charAt(i))
				{
					return false;
				}
			}
			length.argvalue = ilabel.length() - 2;
			return true;
		}
		else if (ilabel.length() > 1) // string
		{
			if (token.length() - ipos < ilabel.length())
			{
				return false;
			}
			for (int i = 0; i < ilabel.length(); i++)
			{
				if (token.charAt(ipos + i) != ilabel.charAt(i))
				{
					return false;
				}
			}
			length.argvalue = ilabel.length();
			return true;
		}
		else
		// character
		{
			// TODO: match with uppercase, unaccented, etc.
			match = iLan.doLettersMatch(token.charAt(ipos), ilabel.charAt(0));
			length.argvalue = 1;
			return match;
		}
	}

	private int morphoMatchLabel(String ilabel, String olabel, String text, int ipos, RefObject<ArrayList> lengths,
			RefObject<ArrayList> inputs, RefObject<ArrayList> outputs)
	{
		lengths.argvalue = null;
		inputs.argvalue = null;
		outputs.argvalue = null;

		if (ilabel.charAt(0) == ':') // recursive call
		{
			Gram grm = (Gram) grams.get(ilabel.substring(1));
			if (grm == null) // not compiled yet
			{
				Graph grf = null;
				for (int i = 0; i < this.graphs.size(); i++)
				{
					grf = (Graph) this.graphs.get(i);
					if (grf != null && grf.name.equals(ilabel.substring(1)))
					{
						break;
					}
				}
				if (grf != null)
				{
					ArrayList aVocab = new ArrayList();
					aVocab.add("<E>");
					HashMap hVocab = new HashMap();
					hVocab.put("<E>", 0);
					grm = grf.compile(iLan, this.gramType, aVocab, hVocab, engine);
					if (grm != null)
					{
						grm.vocab = aVocab;
						hVocab = null;
						grm.prepareForParsing();
					}
					grams.put(grf.name, grm);
				}
				else
				{
					return 0;
				}
			}
			int da = morphoMatch(text.substring(ipos), grm, false, lengths, inputs, outputs);
			// TODO: if the auxiliary node has an output: add <E>/output to each trace
			return da;
		}
		else
		// simple terminal match
		{
			int l = 0;
			RefObject<Integer> tempRef_l = new RefObject<Integer>(l);
			boolean tempVar = morphoMatchTermLabel(ilabel, text, ipos, tempRef_l);
			l = tempRef_l.argvalue;
			if (tempVar)
			{
				lengths.argvalue = new ArrayList();
				lengths.argvalue.add(l);

				// compute the input trace
				ArrayList i = new ArrayList();
				if (ilabel.charAt(0) == '$' && (ilabel.charAt(1) == '(' || ilabel.charAt(1) == ')'))
				{
					// insert the variable marker
					i.add(ilabel);
				}
				else
				// insert the input text
				{
					i.add(text.substring(ipos, ipos + (int) l));
				}
				inputs.argvalue = new ArrayList();
				inputs.argvalue.add(i);
				ArrayList o = new ArrayList();
				o.add(olabel);
				outputs.argvalue = new ArrayList();
				outputs.argvalue.add(o);
				return 1;
			}
			else
			{
				return 0;
			}
		}
	}

	private int debugMorphoMatchLabel(int graphnode, String ilabel, String olabel, String text, int ipos,
			RefObject<ArrayList> lengths, RefObject<ArrayList> inputs, RefObject<ArrayList> outputs,
			RefObject<ArrayList> nodes)
	{
		lengths.argvalue = inputs.argvalue = outputs.argvalue = nodes.argvalue = null;

		if (ilabel.charAt(0) == ':') // recursive call
		{
			String graphname = ilabel.substring(1);
			Gram grm = (Gram) grams.get(graphname);
			if (grm == null) // not compiled yet
			{
				Graph grf = null;
				for (int i = 0; i < this.graphs.size(); i++)
				{
					grf = (Graph) this.graphs.get(i);
					if (grf != null && grf.name.equals(graphname))
					{
						break;
					}
				}
				if (grf != null)
				{
					ArrayList aVocab = new ArrayList();
					aVocab.add("<E>");
					HashMap hVocab = new HashMap();
					hVocab.put("<E>", 0);
					grm = grf.compile(iLan, this.gramType, aVocab, hVocab, engine);
					if (grm != null)
					{
						grm.vocab = aVocab;
						hVocab = null;
						grm.prepareForParsing();
					}
					grams.put(grf.name, grm);
				}
				else
				{
					return 0;
				}
			}
			int da = debugMorphoMatch(graphname, text.substring(ipos), grm, lengths, inputs, outputs, nodes);
			if (da > 0)
			{
				for (int isol = 0; isol < da; isol++)
				{
					// do not touch length
					ArrayList i2 = (ArrayList) inputs.argvalue.get(isol);
					i2.add(0, "");
					ArrayList o2 = (ArrayList) outputs.argvalue.get(isol);
					o2.add(0, olabel);
					ArrayList n2 = (ArrayList) nodes.argvalue.get(isol);
					n2.add(0, graphnode);
				}
			}
			return da;
		}
		else
		// simple terminal match
		{
			int l = 0;
			RefObject<Integer> tempRef_l = new RefObject<Integer>(l);
			boolean tempVar = morphoMatchTermLabel(ilabel, text, ipos, tempRef_l);
			l = tempRef_l.argvalue;
			if (tempVar)
			{
				lengths.argvalue = new ArrayList();
				lengths.argvalue.add(l);

				// compute the input trace
				ArrayList i = new ArrayList();
				if (ilabel.charAt(0) == '$' && (ilabel.charAt(1) == '(' || ilabel.charAt(1) == ')'))
				{
					// insert the variable marker
					i.add(ilabel);
				}
				else
				// insert the input text
				{
					i.add(text.substring(ipos, ipos + (int) l));
				}
				inputs.argvalue = new ArrayList();
				inputs.argvalue.add(i);

				ArrayList o = new ArrayList();
				o.add(olabel);
				outputs.argvalue = new ArrayList();
				outputs.argvalue.add(o);

				ArrayList n = new ArrayList();
				n.add(graphnode);
				nodes.argvalue = new ArrayList();
				nodes.argvalue.add(n);
				return 1;
			}
			else
			{
				return 0;
			}
		}
	}

	static StringBuilder computeInput(ArrayList inputs)
	{
		StringBuilder itrace = new StringBuilder();
		for (int i = 0; i < inputs.size(); i++)
		{
			String si = (String) inputs.get(i);
			if (si != null && !si.equals("") && !si.equals("<E>") && !si.equals("$)")
					&& !(si.charAt(0) == '$' && si.charAt(1) == '('))
			{
				itrace.append(si);
			}
		}
		return itrace;
	}

	private final int morphoMatch(String text, Gram grm, boolean totheend, RefObject<ArrayList> sollengths,
			RefObject<ArrayList> solinputs, RefObject<ArrayList> soloutputs)
	{
		if (!epsilon.equals("<E>"))
		{
			setConstants();
		}

		sollengths.argvalue = solinputs.argvalue = soloutputs.argvalue = null;

		Stack stack = new Stack();
		stack.push(new MTrace());
		while (stack.size() > 0)
		{
			MTrace curtrc = (MTrace) stack.pop();

			State state = (State) grm.states.get(curtrc.Statenb);
			int ipos = curtrc.Pos;
			ArrayList inputs = curtrc.Inputs;
			ArrayList outputs = curtrc.Outputs;

			for (int itrans = 0; itrans < state.Dests.size(); itrans++)
			{
				int dst = (int) state.Dests.get(itrans);
				int lbl = (int) state.IdLabels.get(itrans);
				String ilabel0 = (String) grm.vocabIn.get(lbl);
				String olabel = (String) grm.vocabOut.get(lbl);

				// check for variable in input
				String ilabel;
				if (engine.thereIsAVariableInLabel(ilabel0))
				{
					ilabel = engine.processVariableInMorphoLabel(ilabel0, inputs);
				}
				else
				{
					ilabel = ilabel0;
				}

				ArrayList l2 = null, i2 = null, o2 = null;
				RefObject<ArrayList> tempRef_l2 = new RefObject<ArrayList>(l2);
				RefObject<ArrayList> tempRef_i2 = new RefObject<ArrayList>(i2);
				RefObject<ArrayList> tempRef_o2 = new RefObject<ArrayList>(o2);
				int da = morphoMatchLabel(ilabel, olabel, text, ipos, tempRef_l2, tempRef_i2, tempRef_o2);
				l2 = tempRef_l2.argvalue;
				i2 = tempRef_i2.argvalue;
				o2 = tempRef_o2.argvalue;
				for (int iamb = 0; iamb < da; iamb++)
				{
					int newpos = ipos + (Integer) l2.get(iamb);

					// compute the new trace and insert it in the stack
					MTrace newtrc = new MTrace();
					newtrc.Statenb = dst;
					newtrc.Pos = newpos;
					newtrc.Inputs.addAll(inputs);
					newtrc.Inputs.addAll((ArrayList) i2.get(iamb));
					newtrc.Outputs.addAll(outputs);
					newtrc.Outputs.addAll((ArrayList) o2.get(iamb));

					if (newtrc.Inputs == null || newtrc.Inputs.size() < 1000)
					{
						stack.push(newtrc);
					}

					// reach terminal state ?
					if ((boolean) grm.isTerminal.get(dst)
							&& (!totheend || (newpos >= text.length()) || !Language.isLetter(text.charAt(newpos))))
					{
						if (sollengths.argvalue == null)
						{
							sollengths.argvalue = new ArrayList();
							solinputs.argvalue = new ArrayList();
							soloutputs.argvalue = new ArrayList();
						}
						sollengths.argvalue.add(newpos);
						solinputs.argvalue.add(newtrc.Inputs);
						soloutputs.argvalue.add(newtrc.Outputs);
					}
				}
			}
		}
		if (sollengths.argvalue == null)
		{
			return 0;
		}
		else
		{
			return sollengths.argvalue.size();
		}
	}

	private final int debugMorphoMatch(String graphname, String text, Gram grm, RefObject<ArrayList> sollengths,
			RefObject<ArrayList> solinputs, RefObject<ArrayList> soloutputs, RefObject<ArrayList> solnodes)
	{
		if (!epsilon.equals("<E>"))
		{
			setConstants();
		}

		sollengths.argvalue = solinputs.argvalue = soloutputs.argvalue = solnodes.argvalue = null;

		Stack stack = new Stack();
		stack.push(new MTrace(0, graphname));
		while (stack.size() > 0)
		{
			MTrace curtrc = (MTrace) stack.pop();

			State state = (State) grm.states.get(curtrc.Statenb);
			int ipos = curtrc.Pos;
			int graphnode = state.GraphNodeNumber;
			ArrayList inputs = curtrc.Inputs;
			ArrayList outputs = curtrc.Outputs;
			ArrayList nodes = curtrc.Nodes;

			for (int itrans = 0; itrans < state.Dests.size(); itrans++)
			{
				int dst = (int) state.Dests.get(itrans);
				int lbl = (int) state.IdLabels.get(itrans);
				String ilabel0 = (String) grm.vocabIn.get(lbl);
				String olabel = (String) grm.vocabOut.get(lbl);

				// check for variable in input
				String ilabel;
				if (engine.thereIsAVariableInLabel(ilabel0))
				{
					ilabel = engine.processVariableInMorphoLabel(ilabel0, inputs);
				}
				else
				{
					ilabel = ilabel0;
				}

				ArrayList l2 = null, i2 = null, o2 = null, n2 = null;
				RefObject<ArrayList> tempRef_l2 = new RefObject<ArrayList>(l2);
				RefObject<ArrayList> tempRef_i2 = new RefObject<ArrayList>(i2);
				RefObject<ArrayList> tempRef_o2 = new RefObject<ArrayList>(o2);
				RefObject<ArrayList> tempRef_n2 = new RefObject<ArrayList>(n2);
				int da = debugMorphoMatchLabel(graphnode, ilabel, olabel, text, ipos, tempRef_l2, tempRef_i2,
						tempRef_o2, tempRef_n2);
				l2 = tempRef_l2.argvalue;
				i2 = tempRef_i2.argvalue;
				o2 = tempRef_o2.argvalue;
				n2 = tempRef_n2.argvalue;
				for (int iamb = 0; iamb < da; iamb++)
				{
					int newpos = ipos + (Integer) l2.get(iamb);

					// compute the new trace and insert it in the stack
					MTrace newtrc = new MTrace();
					newtrc.Statenb = dst;
					newtrc.Pos = newpos;
					newtrc.Inputs.addAll(inputs);
					newtrc.Inputs.addAll((ArrayList) i2.get(iamb));
					newtrc.Outputs.addAll(outputs);
					newtrc.Outputs.addAll((ArrayList) o2.get(iamb));
					newtrc.Nodes.addAll(nodes);
					newtrc.Nodes.addAll((ArrayList) n2.get(iamb));

					if (newtrc.Inputs == null || newtrc.Inputs.size() < 1000)
					{
						stack.push(newtrc);
					}

					// reach terminal state ?
					if (dst == 1)
					{
						// add terminal state to nodes and sync with other arrays
						newtrc.Nodes.add(1);
						newtrc.Inputs.add("");
						newtrc.Outputs.add(null);

						if (sollengths.argvalue == null)
						{
							sollengths.argvalue = new ArrayList();
							solinputs.argvalue = new ArrayList();
							soloutputs.argvalue = new ArrayList();
							solnodes.argvalue = new ArrayList();
						}
						sollengths.argvalue.add(newpos);
						solinputs.argvalue.add(newtrc.Inputs);
						soloutputs.argvalue.add(newtrc.Outputs);
						solnodes.argvalue.add(newtrc.Nodes);
					}
				}
			}
		}
		if (sollengths.argvalue == null)
		{
			return 0;
		}
		else
		{
			return sollengths.argvalue.size();
		}
	}

	public final ArrayList matchWord(String text, Engine eng, boolean morethanoneword, String currentline, int cpos)
	{
		engine = eng;
		if (!epsilon.equals("<E>"))
		{
			setConstants();
		}

		Gram grm = (Gram) grams.get("Main");
		if (grm == null)
		{
			return null;
		}
		if (engine.BackgroundWorking)
		{
			if (engine.backgroundWorker.isCancellationPending())
			{
				return null;
			}
		}
		ArrayList slengths = null, sinputs = null, soutputs = null;
		int da;

		RefObject<ArrayList> tempRef_slengths2 = null;
		RefObject<ArrayList> tempRef_sinputs2 = null;
		RefObject<ArrayList> tempRef_soutputs2 = null;

		if (engine.Lan.isoName.equals("ar") || engine.Lan.isoName.equals("he") || engine.Lan.isoName.equals("vi"))
		{
			String text0 = currentline.substring(cpos);
			RefObject<ArrayList> tempRef_slengths = new RefObject<ArrayList>(slengths);
			RefObject<ArrayList> tempRef_sinputs = new RefObject<ArrayList>(sinputs);
			RefObject<ArrayList> tempRef_soutputs = new RefObject<ArrayList>(soutputs);
			da = morphoMatch(text0, grm, true, tempRef_slengths, tempRef_sinputs, tempRef_soutputs);
			slengths = tempRef_slengths.argvalue;
			sinputs = tempRef_sinputs.argvalue;
			soutputs = tempRef_soutputs.argvalue;
		}
		else
		{
			tempRef_slengths2 = new RefObject<ArrayList>(slengths);
			tempRef_sinputs2 = new RefObject<ArrayList>(sinputs);
			tempRef_soutputs2 = new RefObject<ArrayList>(soutputs);
			da = morphoMatch(text, grm, true, tempRef_slengths2, tempRef_sinputs2, tempRef_soutputs2);
		}
		slengths = tempRef_slengths2.argvalue;
		sinputs = tempRef_sinputs2.argvalue;
		soutputs = tempRef_soutputs2.argvalue;

		if (da == 0)
		{
			return null;
		}

		ArrayList sols = new ArrayList();
		for (int isol = 0; isol < da; isol++)
		{
			int stl = (Integer) slengths.get(isol);
			ArrayList sti = (ArrayList) sinputs.get(isol);
			ArrayList sto = (ArrayList) soutputs.get(isol);

			// translate output trace into a string, and process variables
			StringBuilder otrace = processVariablesInOutputs(sti, sto);

			// translate input trace into a string
			StringBuilder itrace = computeInput(sti);

			// is there any remaining lexical constraint ?
			String sol;
			if (isComplex(otrace))
			{
				if (!morethanoneword && hasMoreThanOneWord(otrace))
				{
					continue;
				}
				String errmessage = null;
				RefObject<String> tempRef_errmessage = new RefObject<String>(errmessage);
				ArrayList csols = processConstraints(otrace.toString(), tempRef_errmessage);
				errmessage = tempRef_errmessage.argvalue;
				if (csols == null || csols.isEmpty())
				{
					continue;
				}
				ArrayList listofsols = defactorize(csols);
				for (int icsol = 0; icsol < listofsols.size(); icsol++)
				{
					ArrayList asol = (ArrayList) listofsols.get(icsol);
					engine.processELCSFVariables(asol, text);
					ArrayList asol2 = engine.getRidOfConstraints(asol);
					StringBuilder restrace = computeInput(asol2);
					sol = text + "," + restrace.toString();
					if (stl > text.length())
					{
						sols.add(stl);
					}
					sols.add(sol);
				}
			}
			else
			{
				int count = 0;
				for (int i = 0; i < otrace.length(); i++)
				{
					if (otrace.charAt(i) == '\\')
					{
						i++;
					}
					else if (otrace.charAt(i) == ',')
					{
						count++;
					}
				}
				if (count == 0) // graph produces only info
				{
					sol = text.substring(0, stl) + "," + itrace.toString() + "," + otrace.toString();
				}
				else
				// graph produces lemma and info
				{
					sol = itrace.toString() + "," + otrace.toString();
				}
				sols.add(sol);
			}
		}
		return sols;
	}
	
	// Lexical constraints

	private static boolean isComplex(StringBuilder output)
	{
		for (int i = 0; i < output.length(); i++)
		{
			if (output.charAt(i) == '\\')
			{
				i++;
			}
			else if (output.charAt(i) == '<' || output.charAt(i) == '{')
			{
				return true;
			}
		}
		return false;
	}

	private static boolean hasMoreThanOneWord(StringBuilder output)
	{
		int cpt = 0;
		for (int i = 0; i < output.length(); i++)
		{
			if (output.charAt(i) == '\\')
			{
				i++;
			}
			else if (output.charAt(i) == '{')
			{
				cpt++;
			}
			else if (output.charAt(i) == '<')
			{
				int j;
				for (j = 0; i + j < output.length() && output.charAt(j) != '>'; j++)
				{
					;
				}
				String lexeme = output.toString().substring(i, i + j);
				String entry = null, lemma = null, category = null;
				String[] features = null;
				boolean negation = false;
				RefObject<String> tempRef_entry = new RefObject<String>(entry);
				RefObject<String> tempRef_lemma = new RefObject<String>(lemma);
				RefObject<String> tempRef_category = new RefObject<String>(category);
				RefObject<String[]> tempRef_features = new RefObject<String[]>(features);
				RefObject<Boolean> tempRef_negation = new RefObject<Boolean>(negation);
				boolean tempVar = Dic.parseSymbolFeatureArray(lexeme, tempRef_entry, tempRef_lemma, tempRef_category,
						tempRef_features, tempRef_negation);
				entry = tempRef_entry.argvalue;
				lemma = tempRef_lemma.argvalue;
				category = tempRef_category.argvalue;
				features = tempRef_features.argvalue;
				negation = tempRef_negation.argvalue;
				if (tempVar)
				{
					cpt++;
					i += j;
				}
			}
		}
		return cpt > 1;
	}

	transient private static HashMap perlpatterns;

	private static boolean perlMatch(String wordform, String pattern)
	{
		String rpat;
		if (pattern.charAt(0) == '"' && pattern.charAt(pattern.length() - 1) == '"')
		{
			rpat = pattern.substring(1, 1 + pattern.length() - 2);
		}
		else if (pattern.charAt(0) == '"' || pattern.charAt(pattern.length() - 1) == '"')
		{
			return false;
		}
		else
		{
			rpat = pattern;
		}

		Pattern p;

		if (perlpatterns == null)
		{
			perlpatterns = new HashMap();
			p = Pattern.compile(rpat);
			perlpatterns.put(rpat, p);
		}
		else if (perlpatterns.containsKey(rpat))
		{
			p = (Pattern) perlpatterns.get(rpat);
		}
		else
		{
			p = Pattern.compile(rpat);
			perlpatterns.put(rpat, p);
		}

		Matcher m = p.matcher(wordform);

		return m.find();
	}

	private static String[] extractPerlQueries(String[] features)
	{
		ArrayList res = new ArrayList();
		for (int i = 0; i < features.length; i++)
		{
			if (features[i].length() > 4
					&& (features[i].substring(0, 4).equals("+MP=") || features[i].substring(0, 4).equals("-MP=")))
			{
				if (res == null)
				{
					res = new ArrayList();
				}
				res.add(features[i]);
			}
		}
		return (String[]) res.toArray(new String[res.size()]);
	}

	private static String[] removePerlQueries(String[] features)
	{
		ArrayList res = new ArrayList();
		for (int i = 0; i < features.length; i++)
		{
			if (features[i].length() < 4
					|| (!features[i].substring(0, 4).equals("+MP=") && !features[i].substring(0, 4).equals("-MP=")))
			{
				if (res == null)
				{
					res = new ArrayList();
				}
				res.add(features[i]);
			}
		}
		return (String[]) res.toArray(new String[res.size()]);
	}

	static void filterConstraint(ArrayList sols, String entry, String lemma, String category, String[] features,
			boolean negation)
	{
		String lentry = null, llemma = null, lcategory = null; // information in the lexicon
		String[] lfeatures = null;

		for (int i = 0; i < sols.size();)
		{
			RefObject<String> tempRef_lentry = new RefObject<String>(lentry);
			RefObject<String> tempRef_llemma = new RefObject<String>(llemma);
			RefObject<String> tempRef_lcategory = new RefObject<String>(lcategory);
			RefObject<String[]> tempRef_lfeatures = new RefObject<String[]>(lfeatures);
			Dic.parseDELAFFeatureArray((String) sols.get(i), tempRef_lentry, tempRef_llemma, tempRef_lcategory,
					tempRef_lfeatures);
			lentry = tempRef_lentry.argvalue;
			llemma = tempRef_llemma.argvalue;
			lcategory = tempRef_lcategory.argvalue;
			lfeatures = tempRef_lfeatures.argvalue;

			if (!negation)
			{
				if (category != null && !category.equals("DIC") && !category.equals(lcategory))
				{
					sols.subList(i, 1 + i).clear();
					continue;
				}
				if (lemma != null && !lemma.equals(llemma))
				{
					sols.subList(i, 1 + i).clear();
					continue;
				}

				// categories or lemmas have matched: now match features
				if (features == null || features.length == 0)
				{
					i++;
					continue;
				}
				boolean compatible = true;
				for (int ifeat = 0; ifeat < features.length; ifeat++)
				{
					if (features[ifeat].charAt(0) == '+')
					{
						if (features[ifeat].length() > 4 && features[ifeat].substring(0, 4).equals("+MP="))
						{
							compatible = perlMatch(lentry, features[ifeat].substring(4));
							if (!compatible)
							{
								break;
							}
							continue;
						}
						compatible = false;
						if (lfeatures == null)
						{
							break;
						}
						for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
						{
							if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
							{
								compatible = true;
								break;
							}
							else
							{
								int index = lfeatures[jfeat].indexOf('=');
								if (index != -1)
								{
									if (features[ifeat].substring(1) == lfeatures[jfeat].substring(index + 1))
									{
										compatible = true;
										break;
									}
								}
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
					else
					// if (features[ifeat][0] == '-')
					{
						compatible = true;
						if (lfeatures == null)
						{
							break;
						}
						for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
						{
							if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
							{
								compatible = false;
								break;
							}
							else if (features[ifeat].length() > 5 && features[ifeat].substring(0, 4).equals("-MP="))
							{
								compatible = !perlMatch(entry, features[ifeat].substring(4));
							}
							else
							{
								int index = lfeatures[jfeat].indexOf('=');
								if (index != -1)
								{
									if (features[ifeat].substring(1) == lfeatures[jfeat].substring(index + 1))
									{
										compatible = false;
										break;
									}
								}
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
				}
				if (!compatible)
				{
					sols.subList(i, 1 + i).clear();
					continue;
				}
				i++;
			}
			else
			// negation
			{
				if (category != null && !category.equals("DIC") && !category.equals(lcategory))
				{
					i++;
					continue;
				}
				if (lemma != null && !lemma.equals(llemma))
				{
					i++;
					continue;
				}

				// categories or lemmas match: now match features
				if (features == null || features.length == 0)
				{
					// sols.removeRange(i, 1 + i);
					sols.subList(i, 1 + i).clear();
					continue;
				}
				boolean compatible = true;
				for (int ifeat = 0; ifeat < features.length; ifeat++)
				{
					if (features[ifeat].charAt(0) == '+')
					{
						compatible = false;
						if (lfeatures == null)
						{
							break;
						}
						for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
						{
							if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
							{
								compatible = true;
								break;
							}
							else if (features[ifeat].length() > 5 && features[ifeat].substring(0, 4).equals("+MP="))
							{
								compatible = perlMatch(entry, features[ifeat].substring(4));
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
					else
					// if (features[ifeat][0] == '-')
					{
						compatible = true;
						if (lfeatures == null)
						{
							break;
						}
						for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
						{
							if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
							{
								compatible = false;
								break;
							}
							else if (features[ifeat].length() > 5 && features[ifeat].substring(0, 4).equals("-MP="))
							{
								compatible = !perlMatch(entry, features[ifeat].substring(4));
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
				}
				if (compatible)
				{
					// sols.removeRange(i, 1 + i);
					sols.subList(i, 1 + i).clear();
					continue;
				}
				i++;
			}
		}
	}

	static ArrayList addBracketsAround(ArrayList sols)
	{
		ArrayList result = new ArrayList();
		for (int i = 0; i < sols.size(); i++)
		{
			result.add("{" + (String) sols.get(i) + "}");
		}
		return result;
	}

	private static ArrayList transformConstraintIntoLU(ArrayList sols)
	{
		ArrayList result = new ArrayList();
		for (int i = 0; i < sols.size(); i++)
		{
			String sol = (String) sols.get(i);
			if (sol.charAt(0) == '<' || sol.charAt(0) == '{')
			{
				sol = sol.substring(1, 1 + sol.length() - 2);
			}
			String entry = null, lemma = null, category = null, features = null;
			RefObject<String> tempRef_entry = new RefObject<String>(entry);
			RefObject<String> tempRef_lemma = new RefObject<String>(lemma);
			RefObject<String> tempRef_category = new RefObject<String>(category);
			RefObject<String> tempRef_features = new RefObject<String>(features);
			Dic.parseDELAF(sol, tempRef_entry, tempRef_lemma, tempRef_category, tempRef_features);
			entry = tempRef_entry.argvalue;
			lemma = tempRef_lemma.argvalue;
			category = tempRef_category.argvalue;
			features = tempRef_features.argvalue;
			if (entry == null || entry.equals(""))
			{
				entry = "NA";
			}
			result.add("<LU=" + entry + "," + lemma + "," + category + features + ">");
		}
		return result;
	}

	static ArrayList transformConstraintIntoLUNoLU(ArrayList sols)
	{
		ArrayList result = new ArrayList();
		for (int i = 0; i < sols.size(); i++)
		{
			String sol = (String) sols.get(i);
			if (sol.charAt(0) == '<' || sol.charAt(0) == '{')
			{
				sol = sol.substring(1, 1 + sol.length() - 2);
			}
			String entry = null, lemma = null, category = null, features = null;
			RefObject<String> tempRef_entry = new RefObject<String>(entry);
			RefObject<String> tempRef_lemma = new RefObject<String>(lemma);
			RefObject<String> tempRef_category = new RefObject<String>(category);
			RefObject<String> tempRef_features = new RefObject<String>(features);
			Dic.parseDELAF(sol, tempRef_entry, tempRef_lemma, tempRef_category, tempRef_features);
			entry = tempRef_entry.argvalue;
			lemma = tempRef_lemma.argvalue;
			category = tempRef_category.argvalue;
			features = tempRef_features.argvalue;
			if (entry == null || entry.equals(""))
			{
				entry = "NA";
			}
			result.add("<" + entry + "," + lemma + "," + category + features + ">");
		}
		return result;
	}

	private final ArrayList processConstraints(String tokenSequence, RefObject<String> errmessage)
	{
		String[] tokens;
		ArrayList result = null;

		tokens = iLan.parseSequenceOfTokens(tokenSequence);
		if (tokens == null)
		{
			errmessage.argvalue = "Invalid syntax in info '" + tokenSequence + "'";
			Dic.writeLog(errmessage.argvalue);
			return null;
		}
		for (int i = 0; i < tokens.length; i++)
		{
			String entry = null, lemma = null, category = null;
			String[] features = null;
			String op = null;
			boolean negation = false;
			ArrayList csols;
			if (Dic.isALexicalConstraint(tokens[i]))
			{
				// a lexical constraint
				ArrayList csols0 = null;
				RefObject<String> tempRef_entry = new RefObject<String>(entry);
				RefObject<String> tempRef_lemma = new RefObject<String>(lemma);
				RefObject<String> tempRef_category = new RefObject<String>(category);
				RefObject<String[]> tempRef_features = new RefObject<String[]>(features);
				RefObject<String> tempRef_op = new RefObject<String>(op);
				RefObject<Boolean> tempRef_negation = new RefObject<Boolean>(negation);
				boolean tempVar = !Dic.parseLexicalConstraint(tokens[i], tempRef_entry, tempRef_lemma,
						tempRef_category, tempRef_features, tempRef_op, tempRef_negation);
				entry = tempRef_entry.argvalue;
				lemma = tempRef_lemma.argvalue;
				category = tempRef_category.argvalue;
				features = tempRef_features.argvalue;
				op = tempRef_op.argvalue;
				negation = tempRef_negation.argvalue;
				if (tempVar)
				{
					continue;
				}
				if (!op.equals("=:"))
				{
					errmessage.argvalue = "Morphological parser cannot process operator '" + op + "' in " + tokens[i];
					Dic.writeLog(errmessage.argvalue);
					return null;
				}
				if (category != null && category.length() >= 1) // recursive constraint e.g. <form=:V>
				{
					// category = category.Substring (1);
					if (engine.recursiveMorphology == null)
					{
						engine.recursiveMorphology = new HashMap();
					}
					else if (engine.recursiveMorphology.containsKey(entry))
					{
						errmessage.argvalue = "Infinite recursivity while parsing '" + entry + "' for constraint '"
								+ tokens[i] + "'";
						Dic.writeLog(errmessage.argvalue);
						return null;
					}
					engine.recursiveMorphology.put(entry, null);
					if (this.engine.Lan.isoName.equals("hy") || this.engine.Lan.isoName.equals("sa"))
					{
						// agglutinative languages need to recursively apply embedded morphological grammars
						csols0 = engine.lookupAndAnalyzeSimpleNoComplex(entry);
					}
					else if (this.engine.Lan.rightToLeft)
					{
						// agglutinative language might have a compound
						csols0 = engine.lookupAllCompoundsAndSimpleLexs(entry);
					}
					else
					{
						csols0 = engine.lookupAllSDics(entry); // IF WE WANT IT TO BE RECURSIVE =>
																// engine.LookupAndAnalyzeSimpleNoComplex(entry);
					}
					engine.recursiveMorphology.remove(entry);
				}
				else if (lemma != null && lemma.length() >= 1) // recursive constraint e.g. <form=:eat>
				{
					// lemma = lemma.Substring (1);
					if (engine.recursiveMorphology == null)
					{
						engine.recursiveMorphology = new HashMap();
					}
					else if (engine.recursiveMorphology.containsKey(entry))
					{
						errmessage.argvalue = "Infinite recursivity while parsing '" + entry + "' for constraint '"
								+ tokens[i] + "'";
						Dic.writeLog(errmessage.argvalue);
						return null;
					}

					engine.recursiveMorphology.put(entry, null);
					csols0 = engine.lookupAllSDics(entry); // IF WE WANT IT TO BE RECURSIVE =>
															// engine.LookupAndAnalyzeSimpleNoComplex(entry);
					engine.recursiveMorphology.remove(entry);
				}
				else
				{
					// constraint =: has no lemma nor category???
					errmessage.argvalue = "Constraint '" + tokens[i] + "' has no lemma nor category?";
					Dic.writeLog(errmessage.argvalue);
					return null;
				}
				if (csols0 == null || csols0.isEmpty())
				{
					errmessage.argvalue = "Cannot find lexical entry '" + entry + "' for constraint '" + tokens[i]
							+ "'";
					Dic.writeLog(errmessage.argvalue);
					return null;
				}
				ArrayList csols2 = (ArrayList) csols0.clone();
				if (lemma != null || category != null)
				{
					filterConstraint(csols2, entry, lemma, category, features, negation);
				}
				if (csols2.isEmpty())
				{
					errmessage.argvalue = "Constraint '" + tokens[i] + "' is not satisfied";
					Dic.writeLog(errmessage.argvalue);
					return null;
				}
				csols = transformConstraintIntoLU(csols2); // replace the contraint with a list of lexemes
			}
			else if (tokens[i].charAt(0) == '<' || tokens[i].charAt(0) == '{') // a lexical entry
			{
				csols = new ArrayList();
				csols.add(tokens[i]);
			}
			else
			// a token
			{
				csols = new ArrayList();
				csols.add(tokens[i]);
			}
			if (result == null)
			{
				result = new ArrayList();
			}
			result.add(csols);
		}
		errmessage.argvalue = null;
		return result;
	}

	private void recDefact(ArrayList prefix, ArrayList exp, ArrayList res)
	{
		if (exp.isEmpty())
		{
			res.add(prefix.clone());
		}
		else
		{
			ArrayList fact = (ArrayList) exp.get(0);
			for (int iterm = 0; iterm < fact.size(); iterm++)
			{
				ArrayList tmp = (ArrayList) prefix.clone();
				tmp.add((String) fact.get(iterm));

				// C#'s version GetRange doesn't need to worry about fromIndex and toIndex (as in Java's sublist)!
				ArrayList expSublist = new ArrayList();
				if (exp.size() == 1)
					expSublist = new ArrayList();
				else if (exp.size() == 2)
					expSublist.add(exp.get(1));
				else
					expSublist = (ArrayList) exp.subList(1, exp.size() - 1);
				recDefact(tmp, expSublist, res);

				// recDefact(tmp, (ArrayList) exp.subList(1, exp.size() - 1), res);
			}
		}
	}

	private final ArrayList defactorize(ArrayList expression)
	{
		ArrayList res = new ArrayList();
		recDefact(new ArrayList(), expression, res);
		return res;
	}

	// Syntactic Parsing
	final void xmlFilterMatches(ArrayList lexs, ArrayList lengths, String[] symbols,
			RefObject<ArrayList> reslex, RefObject<ArrayList> reslen)
	{
		reslex.argvalue = new ArrayList();
		reslen.argvalue = new ArrayList();
		for (String symbol : symbols)
		{
			String entry = null, lemma = null, category = null;
			String[] features = null;
			boolean negation = false;
			RefObject<String> tempRef_entry = new RefObject<String>(entry);
			RefObject<String> tempRef_lemma = new RefObject<String>(lemma);
			RefObject<String> tempRef_category = new RefObject<String>(category);
			RefObject<String[]> tempRef_features = new RefObject<String[]>(features);
			RefObject<Boolean> tempRef_negation = new RefObject<Boolean>(negation);
			boolean tempVar = !Dic.parseSymbolFeatureArray(symbol, tempRef_entry, tempRef_lemma, tempRef_category,
					tempRef_features, tempRef_negation);
			entry = tempRef_entry.argvalue;
			lemma = tempRef_lemma.argvalue;
			category = tempRef_category.argvalue;
			features = tempRef_features.argvalue;
			negation = tempRef_negation.argvalue;
			if (tempVar)
			{
				continue;
			}

			ArrayList sols = (ArrayList) lexs.clone();
			ArrayList lens = (ArrayList) lengths.clone();
			RefObject<ArrayList> tempRef_sols = new RefObject<ArrayList>(sols);
			RefObject<ArrayList> tempRef_lens = new RefObject<ArrayList>(lens);
			filterLexemes(tempRef_sols, tempRef_lens, lemma, category, features, negation);
			sols = tempRef_sols.argvalue;
			lens = tempRef_lens.argvalue;
			if (sols.size() > 0)
			{
				reslex.argvalue.addAll(sols);
				reslen.argvalue.addAll(lens);
			}
		}
	}

	private String[] expandLemmas(String word)
	{
		ArrayList lemmas = new ArrayList();
		ArrayList sols = null;
		if (engine != null)
		{
			if (this.iLan.isACompound(word))
			{
				sols = engine.lookupAllLexsForCompounds(0, word);
				if (sols == null || sols.isEmpty())
				{
					// at least set word as a lemma
					lemmas.add(word);
				}
				else
				{
					for (int isols = 0; isols < sols.size(); isols += 2)
					{
						String entry = null, lemma = null, info = null;
						RefObject<String> tempRef_entry = new RefObject<String>(entry);
						RefObject<String> tempRef_lemma = new RefObject<String>(lemma);
						RefObject<String> tempRef_info = new RefObject<String>(info);
						Dic.parseDELAF((String) sols.get(isols), tempRef_entry, tempRef_lemma, tempRef_info);
						entry = tempRef_entry.argvalue;
						lemma = tempRef_lemma.argvalue;
						info = tempRef_info.argvalue;
						if (lemmas.indexOf(lemma) == -1)
						{
							lemmas.add(lemma);
						}
					}
				}
			}
			else
			{
				sols = engine.lookupAllSDics(word);
				if (sols == null || sols.isEmpty())
				{
					// at least set word as a lemma
					lemmas.add(word);
				}
				else
				{
					for (int isols = 0; isols < sols.size(); isols++)
					{
						String entry = null, lemma = null, info = null;
						RefObject<String> tempRef_entry2 = new RefObject<String>(entry);
						RefObject<String> tempRef_lemma2 = new RefObject<String>(lemma);
						RefObject<String> tempRef_info2 = new RefObject<String>(info);
						Dic.parseDELAF((String) sols.get(isols), tempRef_entry2, tempRef_lemma2, tempRef_info2);
						entry = tempRef_entry2.argvalue;
						lemma = tempRef_lemma2.argvalue;
						info = tempRef_info2.argvalue;
						if (lemmas.indexOf(lemma) == -1)
						{
							lemmas.add(lemma);
						}
					}
				}
			}
		}

		return (String[]) lemmas.toArray(new String[lemmas.size()]);
	}

	public final boolean matchLexeme(String lexentry, String lexlemma, String lexcategory, String[] lexfeatures,
			String constraint)
	{
		String consentry = null, conslemma = null, conscategory = null;
		String[] consfeatures = null;
		boolean consnegation = false;
		RefObject<String> tempRef_consentry = new RefObject<String>(consentry);
		RefObject<String> tempRef_conslemma = new RefObject<String>(conslemma);
		RefObject<String> tempRef_conscategory = new RefObject<String>(conscategory);
		RefObject<String[]> tempRef_consfeatures = new RefObject<String[]>(consfeatures);
		RefObject<Boolean> tempRef_consnegation = new RefObject<Boolean>(consnegation);
		Dic.parseSymbolFeatureArray(constraint, tempRef_consentry, tempRef_conslemma, tempRef_conscategory,
				tempRef_consfeatures, tempRef_consnegation);
		consentry = tempRef_consentry.argvalue;
		conslemma = tempRef_conslemma.argvalue;
		conscategory = tempRef_conscategory.argvalue;
		consfeatures = tempRef_consfeatures.argvalue;
		consnegation = tempRef_consnegation.argvalue;

		if (!consnegation)
		{
			if (consentry != null)
			{
				if (!lexentry.equals(consentry))
				{
					return false;
				}
			}
			if (conslemma != null)
			{
				if (!lexlemma.equals(conslemma))
				{
					return false;
				}
			}
			if (conscategory != null)
			{
				if (!lexcategory.equals(conscategory))
				{
					return false;
				}
			}
			if (consfeatures != null)
			{
				boolean compatible = true;
				for (int ifeat = 0; ifeat < consfeatures.length; ifeat++)
				{
					if (consfeatures[ifeat].charAt(0) == '+')
					{
						if (consfeatures[ifeat].length() > 4 && consfeatures[ifeat].substring(0, 4).equals("+MP="))
						{
							compatible = perlMatch(lexentry, consfeatures[ifeat].substring(4));
							if (!compatible)
							{
								return false;
							}
							continue;
						}
						compatible = false;
						if (lexfeatures != null)
						{
							for (int jfeat = 0; jfeat < lexfeatures.length; jfeat++)
							{
								if (lexfeatures[jfeat].equals(consfeatures[ifeat]))
								{
									compatible = true;
									break;
								}
								else
								{
									int index = lexfeatures[jfeat].indexOf('=');
									if (index != -1)
									{
										if (consfeatures[ifeat].substring(1) == lexfeatures[jfeat].substring(index + 1))
										{
											compatible = true;
											break;
										}
									}
								}
							}
						}
						if (!compatible) // not found
						{
							return false;
						}
					}
					else
					// if (consfeatures[ifeat][0]=='-')
					{
						if (consfeatures[ifeat].length() > 4 && consfeatures[ifeat].substring(0, 4).equals("-MP="))
						{
							compatible = !perlMatch(lexentry, consfeatures[ifeat].substring(4));
							if (!compatible)
							{
								return false;
							}
							continue;
						}
						compatible = true;
						if (lexfeatures != null)
						{
							for (int jfeat = 0; jfeat < lexfeatures.length; jfeat++)
							{
								if (consfeatures[ifeat].substring(1) == lexfeatures[jfeat].substring(1))
								{
									compatible = false;
									return false;
								}
								else
								{
									int index = lexfeatures[jfeat].indexOf('=');
									if (index != -1)
									{
										if (consfeatures[ifeat].substring(1) == lexfeatures[jfeat].substring(index + 1))
										{
											compatible = false;
											return false;
										}
									}
								}
							}
						}
						if (!compatible) // not found
						{
							return false;
						}
					}
				}
				if (!compatible)
				{
					return false;
				}
			}
		}
		return true;
	}

	private final void filterLexemes(RefObject<ArrayList> sols, RefObject<ArrayList> lens, String lemma,
			String category, String[] features, boolean negation)
	{
		String lentry = null, llemma = null, lcategory = null; // information in the lexicon
		String[] lfeatures = null;
		String[] lemmas = null;

		// superlemma
		if (lemma != null)
		{
			// replace lemma with lemmas
			if (hlemmas == null)
			{
				hlemmas = new HashMap();
			}
			if (hlemmas.containsKey(lemma))
			{
				lemmas = (String[]) hlemmas.get(lemma);
			}
			else
			{
				if (lemma.equals("SYNTAX"))
				{
					lemmas = new String[1];
					lemmas[0] = "SYNTAX";
				}
				else
				{
					lemmas = expandLemmas(lemma);
				}
				if (lemmas != null)
				{
					hlemmas.put(lemma, lemmas.clone());
				}
			}
		}

		for (int i = 0; i < sols.argvalue.size();)
		{
			RefObject<String> tempRef_lentry = new RefObject<String>(lentry);
			RefObject<String> tempRef_llemma = new RefObject<String>(llemma);
			RefObject<String> tempRef_lcategory = new RefObject<String>(lcategory);
			RefObject<String[]> tempRef_lfeatures = new RefObject<String[]>(lfeatures);
			Dic.parseDELAFFeatureArray((String) sols.argvalue.get(i), tempRef_lentry, tempRef_llemma,
					tempRef_lcategory, tempRef_lfeatures);
			lentry = tempRef_lentry.argvalue;
			llemma = tempRef_llemma.argvalue;
			lcategory = tempRef_lcategory.argvalue;
			lfeatures = tempRef_lfeatures.argvalue;
			if (!negation)
			{
				if (lemma != null)
				{
					boolean foundsuperlemma = false;
					if (lemmas != null)
					{
						for (int ilemma = 0; ilemma < lemmas.length; ilemma++)
						{
							if (llemma.equals(lemmas[ilemma]))
							{
								foundsuperlemma = true;
								break;
							}
						}
					}
					if (!foundsuperlemma)
					{
						sols.argvalue.subList(i, 1 + i).clear();
						lens.argvalue.subList(i, 1 + i).clear();
						continue;
					}
				}

				if (category != null && category.equals("SYNTAX") && llemma != null && llemma.equals("SYNTAX"))
				{
					i++;
					continue;
				}

				if (category != null)
				{
					if (!category.equals("DIC") && !category.equals(lcategory))
					{
						sols.argvalue.subList(i, 1 + i).clear();
						lens.argvalue.subList(i, 1 + i).clear();
						continue;
					}
				}

				// lemmas or/and categories matched: now match features
				if (features == null)
				{
					i++;
					continue;
				}

				boolean compatible = true;
				for (int ifeat = 0; ifeat < features.length; ifeat++)
				{
					if (features[ifeat].charAt(0) == '+')
					{
						if (features[ifeat].length() > 4 && features[ifeat].substring(0, 4).equals("+MP="))
						{
							compatible = perlMatch(lentry, features[ifeat].substring(4));
							if (!compatible)
							{
								break;
							}
							continue;
						}
						compatible = false;
						if (lfeatures != null)
						{
							for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
							{
								if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
								{
									// <N+plural> vs lexeme tables,table+plural
									compatible = true;
									break;
								}
								else
								{
									int index = lfeatures[jfeat].indexOf('=');
									if (index != -1)
									{
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(index + 1))
										{
											// <N+plural> vs lexeme tables,table+Nb=plural
											compatible = true;
											break;
										}
										else if (features[ifeat].substring(1) == lfeatures[jfeat].substring(0, index))
										{
											// <N+FR> vs lexeme eat,V+FR=manger
											compatible = true;
											break;
										}
									}
								}
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
					else
					// if (features[ifeat][0]=='-')
					{
						if (features[ifeat].length() > 4 && features[ifeat].substring(0, 4).equals("-MP="))
						{
							compatible = !perlMatch(lentry, features[ifeat].substring(4));
							if (!compatible)
							{
								break;
							}
							continue;
						}
						compatible = true;
						if (lfeatures != null)
						{
							for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
							{
								if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
								{
									// symbol <N-ZZ> vs lexeme table,N+ZZ
									compatible = false;
									break;
								}
								else
								{
									int index = lfeatures[jfeat].indexOf('=');
									if (index != -1)
									{
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(0, index))
										{
											// symbol <N-ZZ> against vs table,N+ZZ="hello"
											compatible = false;
											break;
										}
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(index + 1))
										{
											// symbol <N-plural> vs lexeme table,N+Number=plural
											compatible = false;
											break;
										}
									}
								}
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
				}
				if (!compatible)
				{
					sols.argvalue.subList(i, 1 + i).clear();
					lens.argvalue.subList(i, 1 + i).clear();
					continue;
				}
				i++;
			}
			else
			{
				// negation
				if (lemma != null)
				{
					boolean foundsuperlemma = false;
					if (lemmas != null)
					{
						for (int ilemma = 0; ilemma < lemmas.length; ilemma++)
						{
							if (llemma.equals(lemmas[ilemma]))
							{
								foundsuperlemma = true;
								break;
							}
						}
					}
					if (!foundsuperlemma)
					{
						i++;
						continue;
					}
				}

				if (category != null)
				{
					if (!category.equals("DIC") && !category.equals(lcategory))
					{
						i++;
						continue;
					}
				}

				// lemmas or/and categories matched: now match features
				if (features == null)
				{
					sols.argvalue.subList(i, 1 + i).clear();
					lens.argvalue.subList(i, 1 + i).clear();
					continue;
				}

				boolean compatible = true;
				for (int ifeat = 0; ifeat < features.length; ifeat++)
				{
					if (features[ifeat].charAt(0) == '+')
					{
						if (features[ifeat].length() > 4 && features[ifeat].substring(0, 4).equals("+MP="))
						{
							compatible = perlMatch(lentry, features[ifeat].substring(4));
							if (!compatible)
							{
								break;
							}
							continue;
						}
						compatible = false;
						if (lfeatures != null)
						{
							for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
							{
								if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
								{
									compatible = true;
									break;
								}
								else
								{
									int index = lfeatures[jfeat].indexOf('=');
									if (index != -1)
									{
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(0, index))
										{
											compatible = true;
											break;
										}
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(index + 1))
										{
											compatible = true;
											break;
										}
									}
								}
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
					else
					// if (features[ifeat][0]=='-')
					{
						if (features[ifeat].length() > 4 && features[ifeat].substring(0, 4).equals("-MP="))
						{
							compatible = !perlMatch(lentry, features[ifeat].substring(4));
							if (!compatible)
							{
								break;
							}
							continue;
						}
						compatible = true;
						if (lfeatures != null)
						{
							for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
							{
								if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
								{
									compatible = false;
									break;
								}
								else
								{
									int index = lfeatures[jfeat].indexOf('=');
									if (index != -1)
									{
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(0, index))
										{
											compatible = false;
											break;
										}
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(index + 1))
										{
											compatible = false;
											break;
										}
									}
								}
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
				}
				if (compatible)
				{
					sols.argvalue.subList(i, 1 + i).clear();
					lens.argvalue.subList(i, 1 + i).clear();
					continue;
				}
				i++;
			}
		}
	}

	// identical to latter, but no lens
	final void filterLexemes(RefObject<ArrayList> sols, String lemma, String category, String[] features,
			boolean negation)
	{
		String lentry = null, llemma = null, lcategory = null; // information in the lexicon
		String[] lfeatures = null;
		String[] lemmas = null;

		// superlemma
		if (lemma != null)
		{
			// replace lemma with lemmas
			if (hlemmas == null)
			{
				hlemmas = new HashMap();
			}
			if (hlemmas.containsKey(lemma))
			{
				lemmas = (String[]) hlemmas.get(lemma);
			}
			else
			{
				lemmas = expandLemmas(lemma);
				if (lemmas != null)
				{
					hlemmas.put(lemma, lemmas.clone());
				}
			}
		}

		for (int i = 0; i < sols.argvalue.size();)
		{
			RefObject<String> tempRef_lentry = new RefObject<String>(lentry);
			RefObject<String> tempRef_llemma = new RefObject<String>(llemma);
			RefObject<String> tempRef_lcategory = new RefObject<String>(lcategory);
			RefObject<String[]> tempRef_lfeatures = new RefObject<String[]>(lfeatures);
			Dic.parseDELAFFeatureArray((String) sols.argvalue.get(i), tempRef_lentry, tempRef_llemma,
					tempRef_lcategory, tempRef_lfeatures);
			lentry = tempRef_lentry.argvalue;
			llemma = tempRef_llemma.argvalue;
			lcategory = tempRef_lcategory.argvalue;
			lfeatures = tempRef_lfeatures.argvalue;
			if (!negation)
			{
				if (lemma != null)
				{
					boolean foundsuperlemma = false;
					if (lemmas != null)
					{
						for (int ilemma = 0; ilemma < lemmas.length; ilemma++)
						{
							if (llemma.equals(lemmas[ilemma]))
							{
								foundsuperlemma = true;
								break;
							}
						}
					}
					if (!foundsuperlemma)
					{
						sols.argvalue.subList(i, 1 + i).clear();
						continue;
					}
				}

				if (category != null)
				{
					if (!category.equals("DIC") && !category.equals(lcategory))
					{
						sols.argvalue.subList(i, 1 + i).clear();
						continue;
					}
				}

				// lemmas or/and categories matched: now match features
				if (features == null)
				{
					i++;
					continue;
				}

				boolean compatible = true;
				for (int ifeat = 0; ifeat < features.length; ifeat++)
				{
					if (features[ifeat].charAt(0) == '+')
					{
						if (features[ifeat].length() > 4 && features[ifeat].substring(0, 4).equals("+MP="))
						{
							compatible = perlMatch(lentry, features[ifeat].substring(4));
							if (!compatible)
							{
								break;
							}
							continue;
						}
						compatible = false;
						if (lfeatures != null)
						{
							for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
							{
								if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
								{
									compatible = true;
									break;
								}
								else
								{
									int index = lfeatures[jfeat].indexOf('=');
									if (index != -1)
									{
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(0, index))
										{
											compatible = true;
											break;
										}
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(index + 1))
										{
											compatible = true;
											break;
										}
									}
								}
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
					else
					// if (features[ifeat][0]=='-')
					{
						if (features[ifeat].length() > 4 && features[ifeat].substring(0, 4).equals("-MP="))
						{
							compatible = !perlMatch(lentry, features[ifeat].substring(4));
							if (!compatible)
							{
								break;
							}
							continue;
						}
						compatible = true;
						if (lfeatures != null)
						{
							for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
							{
								if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
								{
									compatible = false;
									break;
								}
								else
								{
									int index = lfeatures[jfeat].indexOf('=');
									if (index != -1)
									{
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(0, index))
										{
											compatible = false;
											break;
										}
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(index + 1))
										{
											compatible = false;
											break;
										}
									}
								}
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
				}
				if (!compatible)
				{
					sols.argvalue.subList(i, 1 + i).clear();
					continue;
				}
				i++;
			}
			else
			{
				// negation
				if (lemma != null)
				{
					boolean foundsuperlemma = false;
					if (lemmas != null)
					{
						for (int ilemma = 0; ilemma < lemmas.length; ilemma++)
						{
							if (llemma.equals(lemmas[ilemma]))
							{
								foundsuperlemma = true;
								break;
							}
						}
					}
					if (!foundsuperlemma)
					{
						i++;
						continue;
					}
				}

				if (category != null)
				{
					if (!category.equals("DIC") && !category.equals(lcategory))
					{
						i++;
						continue;
					}
				}

				// lemmas or/and categories matched: now match features
				if (features == null)
				{
					sols.argvalue.subList(i, 1 + i).clear();
					continue;
				}

				boolean compatible = true;
				for (int ifeat = 0; ifeat < features.length; ifeat++)
				{
					if (features[ifeat].charAt(0) == '+')
					{
						if (features[ifeat].length() > 4 && features[ifeat].substring(0, 4).equals("+MP="))
						{
							compatible = perlMatch(lentry, features[ifeat].substring(4));
							if (!compatible)
							{
								break;
							}
							continue;
						}
						compatible = false;
						if (lfeatures != null)
						{
							for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
							{
								if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
								{
									compatible = true;
									break;
								}
								else
								{
									int index = lfeatures[jfeat].indexOf('=');
									if (index != -1)
									{
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(0, index))
										{
											compatible = true;
											break;
										}
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(index + 1))
										{
											compatible = true;
											break;
										}
									}
								}
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
					else
					// if (features[ifeat][0]=='-')
					{
						if (features[ifeat].length() > 4 && features[ifeat].substring(0, 4).equals("-MP="))
						{
							compatible = !perlMatch(lentry, features[ifeat].substring(4));
							if (!compatible)
							{
								break;
							}
							continue;
						}
						compatible = true;
						if (lfeatures != null)
						{
							for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
							{
								if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
								{
									compatible = false;
									break;
								}
								else
								{
									int index = lfeatures[jfeat].indexOf('=');
									if (index != -1)
									{
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(0, index))
										{
											compatible = false;
											break;
										}
										if (features[ifeat].substring(1) == lfeatures[jfeat].substring(index + 1))
										{
											compatible = false;
											break;
										}
									}
								}
							}
						}
						if (!compatible) // not found
						{
							break;
						}
					}
				}
				if (compatible)
				{
					sols.argvalue.subList(i, 1 + i).clear();
					continue;
				}
				i++;
			}
		}
	}

	private final void filterNonMatches(RefObject<ArrayList> sols, RefObject<ArrayList> lens, String lemma,
			String category, String[] features)
	{
		String lentry = null, llemma = null, lcategory = null; // information in the lexicon
		String[] lfeatures = null;

		for (int i = 0; i < sols.argvalue.size();)
		{
			RefObject<String> tempRef_lentry = new RefObject<String>(lentry);
			RefObject<String> tempRef_llemma = new RefObject<String>(llemma);
			RefObject<String> tempRef_lcategory = new RefObject<String>(lcategory);
			RefObject<String[]> tempRef_lfeatures = new RefObject<String[]>(lfeatures);
			Dic.parseDELAFFeatureArray((String) sols.argvalue.get(i), tempRef_lentry, tempRef_llemma,
					tempRef_lcategory, tempRef_lfeatures);
			lentry = tempRef_lentry.argvalue;
			llemma = tempRef_llemma.argvalue;
			lcategory = tempRef_lcategory.argvalue;
			lfeatures = tempRef_lfeatures.argvalue;
			if (lemma != null)
			{
				if (!lemma.equals(llemma))
				{
					// NEGATION
					i++;
					continue;
				}
			}

			if (category != null)
			{
				if (category.equals("UNK"))
				{
					// NEGATION
					i++;
					continue;
				}
				else if (!category.equals("DIC") && !category.equals(lcategory))
				{
					// NEGATION
					i++;
					continue;
				}
			}

			// lemmas or/and categories matched: now match features
			if (features == null)
			{
				// HARD NEGATION: remove everything
				sols.argvalue = null;
				lens.argvalue = null;
				return;
				// sols.RemoveRange (i,1);
				// lens.RemoveRange (i,1);
				// continue;
			}

			boolean compatible = true;
			for (int ifeat = 0; ifeat < features.length; ifeat++)
			{
				if (features[ifeat].charAt(0) == '+')
				{
					compatible = false;
					if (lfeatures != null)
					{
						for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
						{
							if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
							{
								compatible = true;
								break;
							}
							else if (features[ifeat].length() > 5 && features[ifeat].substring(0, 4).equals("+MP="))
							{
								compatible = perlMatch(lentry, features[ifeat].substring(4));
							}
						}
					}
					if (!compatible) // not found
					{
						break;
					}
				}
				else
				// if (features[ifeat][0]=='-')
				{
					compatible = true;
					if (lfeatures != null)
					{
						for (int jfeat = 0; jfeat < lfeatures.length; jfeat++)
						{
							if (lfeatures[jfeat].equals(features[ifeat].substring(1)))
							{
								compatible = false;
								break;
							}
							else if (features[ifeat].length() > 5 && features[ifeat].substring(0, 4).equals("-MP="))
							{
								compatible = !perlMatch(lentry, features[ifeat].substring(4));
							}
						}
					}
					if (!compatible) // not found
					{
						break;
					}
				}
			}
			if (!compatible)
			{
				i++;
				continue;
			}
			else
			{
				// hard negation: remove everything
				sols.argvalue = null;
				lens.argvalue = null;
				return;
				// sols.RemoveRange (i,1);
				// lens.RemoveRange (i,1);
			}
		}
	}

	// take care of the +UNAMB or -UNAMB constraints in symbol
	private boolean thereIsPlusUnambIn(String[] features)
	{
		if (features == null)
		{
			return false;
		}
		for (int i = 0; i < features.length; i++)
		{
			if (features[i].equals("+UNAMB"))
			{
				return true;
			}
		}
		return false;
	}

	private boolean thereIsMinusUnambIn(String[] features)
	{
		if (features == null)
		{
			return false;
		}
		for (int i = 0; i < features.length; i++)
		{
			if (features[i].equals("-UNAMB"))
			{
				return true;
			}
		}
		return false;
	}

	private String[] removeUnamb(String[] features)
	{
		ArrayList ares = new ArrayList();
		for (int i = 0; i < features.length; i++)
		{
			if (!features[i].equals("-UNAMB") && !features[i].equals("+UNAMB"))
			{
				ares.add(features[i]);
			}
		}
		if (ares.size() > 0)
		{
			return (String[]) ares.toArray(new String[ares.size()]);
		}
		else
		{
			return null;
		}
	}

	private int matchlexeme(String lemma, String category, String[] features, String text, double cpos, int tunb,
			Mft textmft, ArrayList annotations, RefObject<ArrayList> lengths, RefObject<ArrayList> inputs,
			RefObject<ArrayList> variables)
	{
		lengths.argvalue = null;
		inputs.argvalue = null;
		variables.argvalue = null;

		ArrayList lens = null;
		ArrayList lexids = null;

		RefObject<ArrayList> tempRef_lexids = new RefObject<ArrayList>(lexids);
		RefObject<ArrayList> tempRef_lens = new RefObject<ArrayList>(lens);
		int da = textmft.getAllLexIds(tunb, cpos, tempRef_lexids, tempRef_lens);
		lexids = tempRef_lexids.argvalue;
		lens = tempRef_lens.argvalue;
		if (da == 0)
		{
			if (category != null && category.equals("UNK"))
			{
				double length;
				for (length = 0.0; cpos + (int) length < text.length()
						&& Language.isLetter(text.charAt((int) (cpos + length))); length++)
				{
					;
				}
				if (length == 0.0)
				{
					return 0;
				}

				lengths.argvalue = new ArrayList();
				lengths.argvalue.add(length);
				ArrayList input = new ArrayList();
				input.add(cpos);
				inputs.argvalue = new ArrayList();
				inputs.argvalue.add(input);
				ArrayList variable = new ArrayList();
				variable.add(null);
				variables.argvalue = new ArrayList();
				variables.argvalue.add(variable);
				return 1;
			}
			return 0;
		}

		// take care of +UNAMB or -UNAMB in symbol
		if (thereIsPlusUnambIn(features))
		{
			// if the symbol has +UNAMB, there must be at most one lexeme
			if (da > 1)
			{
				return 0;
			}
			features = removeUnamb(features);
		}
		else if (thereIsMinusUnambIn(features))
		{
			// if the symbol has +UNAMB, there must be at most one lexeme
			if (da == 1)
			{
				return 0;
			}
			features = removeUnamb(features);
		}

		ArrayList sols = new ArrayList();
		for (int i = 0; i < da; i++)
		{
			int tkid = (Integer) lexids.get(i);
			if (tkid >= annotations.size())
			{
				continue;
			}
			String lex = (String) annotations.get(tkid);
			if (lex == null)
			{
				continue;
			}
			sols.add(lex);
		}
		RefObject<ArrayList> tempRef_sols = null;
		RefObject<ArrayList> tempRef_lens2 = null;
		if (da > 0)
		{
			tempRef_sols = new RefObject<ArrayList>(sols);
			tempRef_lens2 = new RefObject<ArrayList>(lens);
			filterLexemes(tempRef_sols, tempRef_lens2, lemma, category, features, false);
		}
		sols = tempRef_sols.argvalue;
		lens = tempRef_lens2.argvalue;
		if (sols == null)
		{
			return 0;
		}
		if (sols.size() > 0)
		{
			inputs.argvalue = new ArrayList();
			variables.argvalue = new ArrayList();
			lengths.argvalue = new ArrayList();
			ArrayList input, variable;
			for (int i = 0; i < sols.size(); i++)
			{
				input = new ArrayList();
				input.add(cpos);
				inputs.argvalue.add(input);
				variable = new ArrayList();
				variable.add((String) sols.get(i));
				variables.argvalue.add(variable);
				long hund_len = (long) (100 * ((Double) lens.get(i)));
				double len = hund_len / 100.0;
				lengths.argvalue.add(len);
			}
		}
		return sols.size();
	}

	private int dontMatchlexeme(String lemma, String category, String[] features, String text, double cpos,
			int startaddr, Mft textmft, ArrayList annotations, RefObject<ArrayList> lengths,
			RefObject<ArrayList> inputs, RefObject<ArrayList> variables)
	{
		lengths.argvalue = null;
		inputs.argvalue = null;
		variables.argvalue = null;

		ArrayList lens = null;
		ArrayList lexids = null;

		double ipos = cpos;
		RefObject<ArrayList> tempRef_lexids = new RefObject<ArrayList>(lexids);
		RefObject<ArrayList> tempRef_lens = new RefObject<ArrayList>(lens);
		int da = textmft.getAllLexIds(startaddr, ipos, tempRef_lexids, tempRef_lens);
		lexids = tempRef_lexids.argvalue;
		lens = tempRef_lens.argvalue;
		if (da == 0 && !category.equals("UNK"))
		{
			double length;
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			if (length == 0)
			{
				return 0;
			}

			// string token = text.Substring ((int) ipos,(int) length);
			length += ipos - cpos;
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			ArrayList input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			ArrayList variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}

		// take care of +UNAMB or -UNAMB in symbol
		// TODO I probably need to inverse these tests
		if (thereIsPlusUnambIn(features))
		{
			// if the symbol has +UNAMB, there must be at most one lexeme
			if (da > 1)
			{
				return 0;
			}
			features = removeUnamb(features);
		}
		else if (thereIsMinusUnambIn(features))
		{
			// if the symbol has +UNAMB, there must be at most one lexeme
			if (da == 1)
			{
				return 0;
			}
			features = removeUnamb(features);
		}

		ArrayList sols = new ArrayList();
		for (int i = 0; i < da; i++)
		{
			int tkid = (Integer) lexids.get(i);
			String lex = (String) annotations.get((int) tkid);
			if (lex == null)
			{
				continue;
			}
			sols.add(lex);
		}

		RefObject<ArrayList> tempRef_sols = null;
		RefObject<ArrayList> tempRef_lens2 = null;
		if (da > 0)
		{
			tempRef_sols = new RefObject<ArrayList>(sols);
			tempRef_lens2 = new RefObject<ArrayList>(lens);
			filterNonMatches(tempRef_sols, tempRef_lens2, lemma, category, features);
		}
		sols = tempRef_sols.argvalue;
		lens = tempRef_lens2.argvalue;
		if (sols == null)
		{
			return 0;
		}
		if (sols.size() > 0)
		{
			inputs.argvalue = new ArrayList();
			variables.argvalue = new ArrayList();
			lengths.argvalue = new ArrayList();
			ArrayList input, variable;
			for (int i = 0; i < sols.size(); i++)
			{
				input = new ArrayList();
				input.add(cpos);
				inputs.argvalue.add(input);
				variable = new ArrayList();
				variable.add((String) sols.get(i));
				variables.argvalue.add(variable);
				lengths.argvalue.add((Double) lens.get(i));
			}
		}
		return sols.size();
	}

	static boolean skipSpaces(String text, RefObject<Double> dpos, boolean xmltext)
	{
		int ipos = (int) ((double) dpos.argvalue);
		if (xmltext)
		{
			while (ipos < text.length() && (Character.isWhitespace(text.charAt(ipos)) || text.charAt(ipos) == '<'))
			{
				if (Character.isWhitespace(text.charAt(ipos)))
				{
					for (; ipos < text.length() && Character.isWhitespace(text.charAt(ipos)); ipos++)
					{
						;
					}
				}
				if (ipos < text.length() && text.charAt(ipos) == '<')
				{
					for (; ipos < text.length() && text.charAt(ipos) != '>'; ipos++)
					{
						;
					}
					ipos++;
				}
			}
		}
		else
		{
			while (ipos < text.length() && (Character.isWhitespace(text.charAt(ipos))))
			{
				if (Character.isWhitespace(text.charAt(ipos)))
				{
					for (; ipos < text.length() && Character.isWhitespace(text.charAt(ipos)); ipos++)
					{
						;
					}
				}
			}
		}
		if (ipos > (int) ((double) dpos.argvalue))
		{
			dpos.argvalue = (double) ipos;
		}
		return ipos < text.length();
	}

	private int syntaxMatchSymbol(String ilabel, String text, double cpos, int tunb, Mft textmft,
			ArrayList annotations, RefObject<ArrayList> lengths, RefObject<ArrayList> inputs,
			RefObject<ArrayList> variables, boolean xmltext)
	{
		double length;
		String token;
		ArrayList input;
		ArrayList variable;
		int match = 0;

		double ipos = cpos;
		RefObject<Double> tempRef_ipos = new RefObject<Double>(ipos);
		boolean tempVar = !skipSpaces(text, tempRef_ipos, xmltext);
		ipos = tempRef_ipos.argvalue;
		if (tempVar)
		{
			inputs.argvalue = null;
			variables.argvalue = null;
			lengths.argvalue = null;
			return 0;
		}

		String entry = null, lemma = null, category = null;
		String[] features = null;
		boolean negation = false;
		RefObject<String> tempRef_entry = new RefObject<String>(entry);
		RefObject<String> tempRef_lemma = new RefObject<String>(lemma);
		RefObject<String> tempRef_category = new RefObject<String>(category);
		RefObject<String[]> tempRef_features = new RefObject<String[]>(features);
		RefObject<Boolean> tempRef_negation = new RefObject<Boolean>(negation);
		boolean tempVar2 = !Dic.parseSymbolFeatureArray(ilabel, tempRef_entry, tempRef_lemma, tempRef_category,
				tempRef_features, tempRef_negation);
		entry = tempRef_entry.argvalue;
		lemma = tempRef_lemma.argvalue;
		category = tempRef_category.argvalue;
		features = tempRef_features.argvalue;
		negation = tempRef_negation.argvalue;
		if (tempVar2)
		{
			inputs.argvalue = null;
			variables.argvalue = null;
			lengths.argvalue = null;
			return 0;
		}
		if (lemma != null && (lemma.equals("^") || lemma.equals("$")) && category == null)
		{
			category = lemma;
		}
		String[] pfeatures = null;
		if (features != null)
		{
			pfeatures = extractPerlQueries(features);
		}
		if (pfeatures != null && pfeatures.length > 0)
		{
			// precompute the tok just for PERL
			int plen = 0;
			if (iLan.asianTokenizer)
			{
				plen = 1;
			}
			else if (Character.isDigit(text.charAt((int) ipos)) && category.equals("NB"))
			{
				for (plen = 0; ipos + plen < text.length() && Character.isDigit(text.charAt((int) ipos + plen)); plen++)
				{
					;
				}
			}
			else if (Language.isLetter(text.charAt((int) ipos)))
			{
				for (plen = 0; ipos + plen < text.length() && Language.isLetter(text.charAt((int) ipos + plen)); plen++)
				{
					;
				}
			}
			else
			{
				plen = 1;
			}
			// if (plen == 0)
			// {
			// inputs = null;
			// variables = null;
			// lengths = null;
			// return 0; // no word form here
			// }
			String tok = text.substring((int) ipos, (int) ipos + plen);
			for (int iperl = 0; iperl < pfeatures.length; iperl++)
			{
				boolean pm = perlMatch(tok, pfeatures[iperl].substring(4));
				if (pfeatures[iperl].charAt(0) == '+' && !pm)
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}
				else if (pfeatures[iperl].charAt(0) == '-' && pm)
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}
			}
			features = removePerlQueries(features);
		}
		// C# TO JAVA CONVERTER NOTE: The following 'switch' operated on a string member and was converted to Java
		// 'if-else' logic:
		// switch (category)
		// ORIGINAL LINE: case "WF":
		if (category != null && category.equals("WF")) // any word form: WORKS ALSO ON ASIAN LANGUAGES
		{
			if (this.iLan.asianTokenizer)
			{
				if (Language.isLetter(text.charAt((int) ipos)))
				{
					token = text.substring((int) ipos, (int) ipos + 1);
					length = 1;
				}
				else
				{
					token = "";
					length = 0;
				}
			}
			else
			{
				for (length = 0; ipos + (int) length < text.length()
						&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
				{
					;
				}
				token = text.substring((int) ipos, (int) ipos + (int) length);
			}
			if (length == 0)
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}
			length += ipos - cpos;
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + "," + token + "," + "WF");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "^":
		else if (category != null && category.equals("^")) // beginning of text unit
		{
			for (int k = (int) ipos - 1; k > 0; k--)
			{
				if (!Character.isWhitespace(text.charAt(k)))
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}
			}
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(0.0);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "$":
		else if (category != null && category.equals("$")) // end of text unit
		{
			for (int k = (int) ipos; k < text.length(); k++)
			{
				if (!Character.isWhitespace(text.charAt(k)))
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}
			}
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(0.0);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "UPP":
		else if (category != null && category.equals("UPP")) // uppercase word form
		{
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			length += ipos - cpos;
			if (!Language.isUpper(token))
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}

			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + "," + token + "," + "UPP");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "U":
		else if (category != null && category.equals("U")) // one-letter uppercase word form
		{
			if (this.iLan.isoName.equals("ja"))
			{
				if (Language.isUniHan(text.charAt((int) ipos)))
				{
					token = text.substring((int) ipos, (int) ipos + 1);
					length = 1;
				}
				else
				{
					token = "";
					length = 0;
				}
				length += ipos - cpos;
				if (token.length() != 1)
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}

				lengths.argvalue = new ArrayList();
				lengths.argvalue.add(length);
				input = new ArrayList();
				input.add(ipos);
				inputs.argvalue = new ArrayList();
				inputs.argvalue.add(input);
				variable = new ArrayList();
				variable.add(token + "," + token + "," + "L");
				variables.argvalue = new ArrayList();
				variables.argvalue.add(variable);
				return 1;
			}
			else
			{
				for (length = 0; ipos + (int) length < text.length()
						&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
				{
					;
				}
				token = text.substring((int) ipos, (int) ipos + (int) length);
				length += ipos - cpos;
				if (!Language.isUpper(token) || token.length() != 1)
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}

				lengths.argvalue = new ArrayList();
				lengths.argvalue.add(length);
				input = new ArrayList();
				input.add(ipos);
				inputs.argvalue = new ArrayList();
				inputs.argvalue.add(input);
				variable = new ArrayList();
				variable.add(token + "," + token + "," + "U");
				variables.argvalue = new ArrayList();
				variables.argvalue.add(variable);
				return 1;
			}
		}
		// ORIGINAL LINE: case "H":
		else if (category != null && category.equals("H")) // one-letter Hiragana word form: WORKS ONLY ON JAPANESE
		{
			if (this.iLan.isoName.equals("ja"))
			{
				if (Language.isHiragana(text.charAt((int) ipos)))
				{
					token = text.substring((int) ipos, (int) ipos + 1);
					length = 1;
				}
				else
				{
					token = "";
					length = 0;
				}
				length += ipos - cpos;
				if (token.length() != 1)
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}

				lengths.argvalue = new ArrayList();
				lengths.argvalue.add(length);
				input = new ArrayList();
				input.add(ipos);
				inputs.argvalue = new ArrayList();
				inputs.argvalue.add(input);
				variable = new ArrayList();
				variable.add(token + "," + token + "," + "L");
				variables.argvalue = new ArrayList();
				variables.argvalue.add(variable);
				return 1;
			}
			else
			{
				match = matchlexeme(lemma, category, features, text, ipos, tunb, textmft, annotations, lengths, inputs,
						variables);
				if (match == 0)
				{
					return 0;
				}
				for (int isol = 0; isol < lengths.argvalue.size(); isol++)
				{
					double len = (Double) lengths.argvalue.get(isol);
					lengths.argvalue.set(isol, len + ipos - cpos);
				}
				return match;
			}
		}
		// ORIGINAL LINE: case "K":
		else if (category != null && category.equals("K")) // one-letter Katakana word form: WORKS ONLY ON JAPANESE
		{
			if (this.iLan.isoName.equals("ja"))
			{
				if (Language.isKatakana(text.charAt((int) ipos)))
				{
					token = text.substring((int) ipos, (int) ipos + 1);
					length = 1;
				}
				else
				{
					token = "";
					length = 0;
				}
				length += ipos - cpos;
				if (token.length() != 1)
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}

				lengths.argvalue = new ArrayList();
				lengths.argvalue.add(length);
				input = new ArrayList();
				input.add(ipos);
				inputs.argvalue = new ArrayList();
				inputs.argvalue.add(input);
				variable = new ArrayList();
				variable.add(token + "," + token + "," + "L");
				variables.argvalue = new ArrayList();
				variables.argvalue.add(variable);
				return 1;
			}
			else
			{
				match = matchlexeme(lemma, category, features, text, ipos, tunb, textmft, annotations, lengths, inputs,
						variables);
				if (match == 0)
				{
					return 0;
				}
				for (int isol = 0; isol < lengths.argvalue.size(); isol++)
				{
					double len = (Double) lengths.argvalue.get(isol);
					lengths.argvalue.set(isol, len + ipos - cpos);
				}
				return match;
			}
		}
		// ORIGINAL LINE: case "L":
		else if (category != null && category.equals("L")) // one-letter word form: WORKS ALSO ON ASIAN LANGUAGES
		{
			if (this.iLan.asianTokenizer)
			{
				if (Language.isLetter(text.charAt((int) ipos)))
				{
					token = text.substring((int) ipos, (int) ipos + 1);
					length = 1;
				}
				else
				{
					token = "";
					length = 0;
				}
			}
			else
			{
				for (length = 0; ipos + (int) length < text.length()
						&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
				{
					;
				}
				token = text.substring((int) ipos, (int) ipos + (int) length);
			}
			length += ipos - cpos;
			if (token.length() != 1)
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}

			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + "," + token + "," + "L");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "W":
		else if (category != null && category.equals("W")) // one-letter lowercase word form
		{
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			length += ipos - cpos;
			if (!Language.isLower(token) || token.length() != 1)
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}

			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + "," + token + "," + "W");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "LOW":
		else if (category != null && category.equals("LOW")) // lowercase word form
		{
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			length += ipos - cpos;
			if (!Language.isLower(token))
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}

			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + "," + token + "," + "LOW");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "CAP":
		else if (category != null && category.equals("CAP")) // first letter is uppercase
		{
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			length += ipos - cpos;
			if (!Language.isCapital(token))
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}

			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + "," + token + "," + "CAP");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "P":
		else if (category != null && category.equals("P")) // any delimiter
		{
			match = ipos < text.length() && !Language.isLetter(text.charAt((int) ipos))
					&& !Character.isDigit(text.charAt((int) ipos)) ? 1 : 0;
			if (match == 0)
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}

			token = text.substring((int) ipos, (int) ipos + 1);
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(1.0 + ipos - cpos);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + "," + token + "," + "P");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "D":
		else if (category != null && category.equals("D")) // any digit
		{
			match = ipos < text.length() && Character.isDigit(text.charAt((int) ipos)) ? 1 : 0;
			if (match == 0)
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}

			token = text.substring((int) ipos, (int) ipos + 1);
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(1.0 + ipos - cpos);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + "," + token + "," + "D");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "NB":
		else if (category != null && category.equals("NB")) // any sequence of digits
		{
			match = ipos < text.length() && Character.isDigit(text.charAt((int) ipos)) ? 1 : 0;
			if (match == 0)
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}

			for (length = 0; ipos + (int) length < text.length()
					&& Character.isDigit(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length + ipos - cpos);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + "," + token + "," + "NB");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		else
		// lexeme
		{
			match = matchlexeme(lemma, category, features, text, ipos, tunb, textmft, annotations, lengths, inputs,
					variables);
			if (match == 0)
			{
				return 0;
			}
			for (int isol = 0; isol < lengths.argvalue.size(); isol++)
			{
				double len = (Double) lengths.argvalue.get(isol);
				lengths.argvalue.set(isol, len + ipos - cpos);
			}
			return match;
		}
	}

	private int syntaxDontMatchSymbol(String ilabel, String text, double cpos, int startaddr, Mft textmft,
			ArrayList annotations, RefObject<ArrayList> lengths, RefObject<ArrayList> inputs,
			RefObject<ArrayList> variables, boolean xmltext)
	{
		double length;
		String token;
		ArrayList input;
		ArrayList variable;
		int match = 0;
		inputs.argvalue = null;
		variables.argvalue = null;
		lengths.argvalue = null;

		double ipos = cpos;
		RefObject<Double> tempRef_ipos = new RefObject<Double>(ipos);
		boolean tempVar = !skipSpaces(text, tempRef_ipos, xmltext);
		ipos = tempRef_ipos.argvalue;
		if (tempVar)
		{
			return 0;
		}

		String entry = null, lemma = null, category = null;
		String[] features = null;
		boolean negation = false;
		RefObject<String> tempRef_entry = new RefObject<String>(entry);
		RefObject<String> tempRef_lemma = new RefObject<String>(lemma);
		RefObject<String> tempRef_category = new RefObject<String>(category);
		RefObject<String[]> tempRef_features = new RefObject<String[]>(features);
		RefObject<Boolean> tempRef_negation = new RefObject<Boolean>(negation);
		boolean tempVar2 = !Dic.parseSymbolFeatureArray(ilabel, tempRef_entry, tempRef_lemma, tempRef_category,
				tempRef_features, tempRef_negation);
		entry = tempRef_entry.argvalue;
		lemma = tempRef_lemma.argvalue;
		category = tempRef_category.argvalue;
		features = tempRef_features.argvalue;
		negation = tempRef_negation.argvalue;
		if (tempVar2)
		{
			return 0;
		}
		String[] pfeatures = null;
		if (features != null)
		{
			pfeatures = extractPerlQueries(features);
		}
		if (pfeatures != null && pfeatures.length > 0)
		{
			// precompute the tok just for PERL
			int plen;
			if (iLan.asianTokenizer)
			{
				plen = 1;
			}
			else if (Character.isDigit(text.charAt((int) ipos)) && category.equals("NB"))
			{
				for (plen = 0; ipos + plen < text.length() && Character.isDigit(text.charAt((int) ipos + plen)); plen++)
				{
					;
				}
			}
			else if (Language.isLetter(text.charAt((int) ipos)))
			{
				for (plen = 0; ipos + plen < text.length() && Language.isLetter(text.charAt((int) ipos + plen)); plen++)
				{
					;
				}
			}
			else
			{
				plen = 1;
			}

			String tok = text.substring((int) ipos, (int) ipos + plen);
			for (int iperl = 0; iperl < pfeatures.length; iperl++)
			{
				boolean pm = perlMatch(tok, pfeatures[iperl].substring(4));
				if (features[iperl].charAt(0) == '+' && pm) // NEGATION
				{
					return 0;
				}
				else if (features[iperl].charAt(0) == '-' && !pm) // NEGATION
				{
					return 0;
				}
			}

			features = removePerlQueries(features);
		}
		boolean foundanonspace;
		// C# TO JAVA CONVERTER NOTE: The following 'switch' operated on a string member and was converted to Java
		// 'if-else' logic:
		// switch (category)
		// ORIGINAL LINE: case "WF":
		if (category.equals("WF")) // any word form
		{
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			if (length > 0) // NEGATION
			{
				if (pfeatures == null || pfeatures.length == 0)
				{
					return 0;
				}
			}

			token = text.substring((int) ipos, (int) ipos + (int) length);
			length += ipos - cpos;
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "^":
		else if (category.equals("^")) // beginning of text unit
		{
			foundanonspace = false;
			for (int k = (int) ipos - 1; k > 0; k--)
			{
				if (!Character.isWhitespace(text.charAt(k)))
				{
					foundanonspace = true;
					break;
				}
			}
			if (!foundanonspace)
			{
				return 0;
			}
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(0.0);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "$":
		else if (category.equals("$")) // end of text unit
		{
			foundanonspace = false;
			for (int k = (int) ipos; k < text.length(); k++)
			{
				if (!Character.isWhitespace(text.charAt(k)))
				{
					foundanonspace = true;
					break;
				}
			}
			if (!foundanonspace)
			{
				return 0;
			}
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(0.0);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "UPP":
		else if (category.equals("UPP")) // uppercase word form
		{
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			length += ipos - cpos;
			if (Language.isUpper(token)) // NEGATION
			{
				if (pfeatures == null || pfeatures.length == 0)
				{
					return 0;
				}
			}

			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "U":
		else if (category.equals("U")) // one-letter uppercase word form
		{
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			length += ipos - cpos;
			if (Language.isUpper(token) && token.length() == 1) // NEGATION
			{
				if (pfeatures == null || pfeatures.length == 0)
				{
					return 0;
				}
			}

			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "L":
		else if (category.equals("L")) // one-letter word form
		{
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			length += ipos - cpos;
			if (token.length() == 1) // NEGATION
			{
				if (pfeatures == null || pfeatures.length == 0)
				{
					return 0;
				}
			}

			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "W":
		else if (category.equals("W")) // one-letter lowercase word form
		{
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			length += ipos - cpos;
			if (Language.isLower(token) && token.length() == 1) // NEGATION
			{
				if (pfeatures == null || pfeatures.length == 0)
				{
					return 0;
				}
			}

			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "LOW":
		else if (category.equals("LOW")) // lowercase word form
		{
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			length += ipos - cpos;
			if (Language.isLower(token)) // NEGATION
			{
				if (pfeatures == null || pfeatures.length == 0)
				{
					return 0;
				}
			}

			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "CAP":
		else if (category.equals("CAP")) // first letter is uppercase
		{
			for (length = 0; ipos + (int) length < text.length()
					&& Language.isLetter(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			length += ipos - cpos;
			if (Language.isCapital(token)) // NEGATION
			{
				if (pfeatures == null || pfeatures.length == 0)
				{
					return 0;
				}
			}

			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "P":
		else if (category.equals("P")) // any delimiter
		{
			match = ipos < text.length() && !Language.isLetter(text.charAt((int) ipos))
					&& !Character.isDigit(text.charAt((int) ipos)) ? 1 : 0;
			if (match == 1) // NEGATION
			{
				if (pfeatures == null || pfeatures.length == 0)
				{
					return 0;
				}
			}

			token = text.substring((int) ipos, (int) ipos + 1);
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(1.0 + ipos - cpos);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "D":
		else if (category.equals("D")) // any digit
		{
			match = ipos < text.length() && Character.isDigit(text.charAt((int) ipos)) ? 1 : 0;
			if (match == 1) // NEGATION
			{
				if (pfeatures == null || pfeatures.length == 0)
				{
					return 0;
				}
			}

			token = text.substring((int) ipos, (int) ipos + 1);
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(1.0 + ipos - cpos);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		// ORIGINAL LINE: case "NB":
		else if (category.equals("NB")) // any sequence of digits
		{
			match = ipos < text.length() && Character.isDigit(text.charAt((int) ipos)) ? 1 : 0;
			if (match == 1) // NEGATION
			{
				if (pfeatures == null || pfeatures.length == 0)
				{
					return 0;
				}
			}

			for (length = 0; ipos + (int) length < text.length()
					&& Character.isDigit(text.charAt((int) ipos + (int) length)); length++)
			{
				;
			}
			token = text.substring((int) ipos, (int) ipos + (int) length);
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length + ipos - cpos);
			input = new ArrayList();
			input.add(ipos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(null);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		else
		// lexeme
		{
			match = dontMatchlexeme(lemma, category, features, text, ipos, startaddr, textmft, annotations, lengths,
					inputs, variables);
			if (match > 0)
			{
				for (int isol = 0; isol < lengths.argvalue.size(); isol++)
				{
					double len = (Double) lengths.argvalue.get(isol);
					lengths.argvalue.set(isol, len + ipos - cpos);
				}
			}
			return match;
		}
	}

	private int syntaxMatchTermLabel(String ilabel, String text, double cpos, double cposafterspaces, int tunb,
			Mft textmft, ArrayList annotations, RefObject<ArrayList> lengths, RefObject<ArrayList> inputs,
			RefObject<ArrayList> variables, boolean xmltext)
	{
		double length;
		String token;
		ArrayList input;
		ArrayList variable;
		int match;

		if (ilabel.charAt(0) == '<')
		{
			if (ilabel.length() == 3 && ilabel.charAt(1) == 'E' && ilabel.charAt(2) == '>')
			{
				lengths.argvalue = new ArrayList();
				lengths.argvalue.add(0.0);
				input = new ArrayList();
				input.add(cpos);
				inputs.argvalue = new ArrayList();
				inputs.argvalue.add(input);
				variable = new ArrayList();
				variable.add(null);
				variables.argvalue = new ArrayList();
				variables.argvalue.add(variable);
				return 1;
			}
		}
		else if (ilabel.charAt(0) == '$' && ilabel.length() >= 2
				&& (ilabel.charAt(1) == '(' || ilabel.charAt(1) == ')'))
		{
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(0.0);
			input = new ArrayList();
			input.add(cpos);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(ilabel);
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}

		if (cpos >= text.length())
		{
			if (ilabel.equals("<$>"))
			{
				lengths.argvalue = new ArrayList(); // go beyond text's end in order to make sure we stop
													// looping in case we have a loop on <$><$><�>
				lengths.argvalue.add(1.0);
				input = new ArrayList();
				input.add(cpos);
				inputs.argvalue = new ArrayList();
				inputs.argvalue.add(input);
				variable = new ArrayList();
				variable.add("END,WF");
				variables.argvalue = new ArrayList();
				variables.argvalue.add(variable);
				return 1;
			}
			else
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}
		}
		if (ilabel.charAt(0) == '#' && ilabel.length() == 1)
		{
			inputs.argvalue = null;
			variables.argvalue = null;
			lengths.argvalue = null;
			if (Character.isWhitespace(text.charAt((int) cpos)))
			{
				return 0;
			}
			else
			{
				return 1;
			}
		}

		if (ilabel.charAt(0) == '<')
		{
			if (ilabel.charAt(1) == '!')
			{
				return syntaxDontMatchSymbol(ilabel, text, cpos, tunb, textmft, annotations, lengths, inputs,
						variables, xmltext);
			}
			else
			{
				return syntaxMatchSymbol(ilabel, text, cpos, tunb, textmft, annotations, lengths, inputs, variables,
						xmltext);
			}
		}
		else if (Language.isLetter(ilabel.charAt(0))) // wordform
		{
			token = ilabel;
			if (cposafterspaces >= text.length()) // !SkipSpaces (text,ref ipos,xmltext))
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}
			if (iLan.asianTokenizer)
			{
				length = 1.0;
				match = (text.charAt((int) cposafterspaces) == ilabel.charAt(0)) ? 1 : 0;
			}
			else
			{
				for (length = 0; cposafterspaces + (int) length < text.length()
						&& Language.isLetter(text.charAt((int) cposafterspaces + (int) length)); length++)
				{
					;
				}
				token = text.substring((int) cposafterspaces, (int) cposafterspaces + (int) length);
				match = iLan.doWordFormsMatch(token, ilabel) ? 1 : 0;
			}
			length += cposafterspaces - cpos;

			if (match != 0)
			{
				lengths.argvalue = new ArrayList();
				lengths.argvalue.add(length);
				input = new ArrayList();
				input.add(cposafterspaces);
				inputs.argvalue = new ArrayList();
				inputs.argvalue.add(input);
				variable = new ArrayList();
				variable.add(token + ",WF");
				variables.argvalue = new ArrayList();
				variables.argvalue.add(variable);
			}
			else
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
			}
			return match;
		}
		else if (ilabel.charAt(0) == '"') // protected sequence
		{
			StringBuilder sb = new StringBuilder();
			for (int i2 = 0; i2 < ilabel.length(); i2++)
			{
				if (ilabel.charAt(i2) == ',')
				{
					sb.append("\\,");
				}
				else
				{
					sb.append(ilabel.charAt(i2));
				}
			}
			token = sb.toString();

			if (Character.isWhitespace(ilabel.charAt(1)))
			{
				if (cpos >= text.length()) // (!SkipSpaces (text,ref ipos,xmltext))
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}
				int i;
				for (i = 0; i < ilabel.length() - 2; i++)
				{
					if (cpos + i >= text.length())
					{
						inputs.argvalue = null;
						variables.argvalue = null;
						lengths.argvalue = null;
						return 0;
					}
					if (text.charAt((int) cpos + i) != ilabel.charAt(i + 1))
					{
						inputs.argvalue = null;
						variables.argvalue = null;
						lengths.argvalue = null;
						return 0;
					}
				}
				length = (int) (ilabel.length() - 2 + cposafterspaces - cpos);
				lengths.argvalue = new ArrayList();
				lengths.argvalue.add(length + cposafterspaces - cpos);
				input = new ArrayList();
				input.add(cposafterspaces);
				inputs.argvalue = new ArrayList();
				inputs.argvalue.add(input);
				variable = new ArrayList();
				variable.add(token + ",WF");
				variables.argvalue = new ArrayList();
				variables.argvalue.add(variable);
				return 1;
			}
			else if (Character.isLetter(ilabel.charAt(1)) && Character.isLetter(ilabel.charAt(ilabel.length() - 2))) // e.g.
																														// ilabel
																														// ==
																														// "\"the\""
			{
				// make sure that the match is complete
				if (cposafterspaces + ilabel.length() - 2 < text.length()
						&& Character.isLetter(text.charAt((int) cposafterspaces + ilabel.length() - 2)))
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}
				for (int i = 0; i < ilabel.length() - 2; i++)
				{
					if (cposafterspaces + i >= text.length())
					{
						inputs.argvalue = null;
						variables.argvalue = null;
						lengths.argvalue = null;
						return 0;
					}
					if (text.charAt((int) cposafterspaces + i) != ilabel.charAt(i + 1))
					{
						inputs.argvalue = null;
						variables.argvalue = null;
						lengths.argvalue = null;
						return 0;
					}
				}
			}
			else if (!Character.isWhitespace(ilabel.charAt(1)))
			{
				if (cposafterspaces >= text.length()) // (!SkipSpaces (text,ref ipos,xmltext))
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}
				for (int i = 0; i < ilabel.length() - 2; i++)
				{
					if (cposafterspaces + i >= text.length())
					{
						inputs.argvalue = null;
						variables.argvalue = null;
						lengths.argvalue = null;
						return 0;
					}
					if (text.charAt((int) cposafterspaces + i) != ilabel.charAt(i + 1))
					{
						inputs.argvalue = null;
						variables.argvalue = null;
						lengths.argvalue = null;
						return 0;
					}
				}
			}
			length = (int) (ilabel.length() - 2 + cposafterspaces - cpos);
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(length + cposafterspaces - cpos);
			input = new ArrayList();
			input.add(cposafterspaces);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + ",WF");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return 1;
		}
		else if (ilabel.charAt(0) == '\\') // protected char
		{
			token = ilabel;
			if (!Character.isWhitespace(ilabel.charAt(1)))
			{
				if (cposafterspaces >= text.length()) // !SkipSpaces (text,ref ipos,xmltext))
				{
					inputs.argvalue = null;
					variables.argvalue = null;
					lengths.argvalue = null;
					return 0;
				}
			}
			match = (text.charAt((int) cposafterspaces) == ilabel.charAt(1)) ? 1 : 0;
			if (match == 0)
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(1.0 + cposafterspaces - cpos);
			input = new ArrayList();
			input.add(cposafterspaces);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + ",WF");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return match;
		}
		else
		// delimiter
		{
			if (ilabel.equals(","))
			{
				token = "\\,";
			}
			else
			{
				token = ilabel;
			}
			if (cposafterspaces >= text.length()) // !SkipSpaces (text,ref ipos,xmltext))
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}
			match = (text.charAt((int) cposafterspaces) == ilabel.charAt(0)) ? 1 : 0;
			if (match == 0)
			{
				inputs.argvalue = null;
				variables.argvalue = null;
				lengths.argvalue = null;
				return 0;
			}
			lengths.argvalue = new ArrayList();
			lengths.argvalue.add(1.0 + cposafterspaces - cpos);
			input = new ArrayList();
			input.add(cposafterspaces);
			inputs.argvalue = new ArrayList();
			inputs.argvalue.add(input);
			variable = new ArrayList();
			variable.add(token + ",WF");
			variables.argvalue = new ArrayList();
			variables.argvalue.add(variable);
			return match;
		}
	}

	private int debugSyntaxMatchLabel(int graphnode, String ilabel, String olabel, String text, double cpos,
			double cposafterspaces, int tunb, Mft textmft, ArrayList annotations, RefObject<ArrayList> lengths,
			RefObject<ArrayList> inputs, RefObject<ArrayList> variables, RefObject<ArrayList> outputs,
			RefObject<ArrayList> nodes, boolean xmltext, ArrayList RecursiveCalls, Gram currentgram)
	{
		lengths.argvalue = null;
		inputs.argvalue = null;
		variables.argvalue = null;
		outputs.argvalue = null;
		nodes.argvalue = null;

		if (ilabel.charAt(0) == ':'
				|| (ilabel.charAt(0) == '$' && ilabel.length() >= 2 && ilabel.charAt(1) != '(' && ilabel.charAt(1) != ')')) // recursive
																															// call
		{
			String graphname = ilabel.substring(1);
			Gram grm = null;
			if (!grams.containsKey(graphname))
			{
				// gram :graphname or $graphname does not exist in the grammar: maybe in a variable definition $(var ...
				// $)
				grm = currentgram.getGramFromVariableDefinition(graphname);
				grams.put(graphname, grm);
			}
			else
			{
				grm = (Gram) grams.get(graphname);
			}

			if (nbOfRecursiveCalls(ilabel, RecursiveCalls) > 10)
			{
				return 0;
			}

			if (grm == null) // not compiled yet
			{
				Graph grf = null;
				if (this.graphs != null)
				{
					for (int i = 0; i < this.graphs.size(); i++)
					{
						Graph cgrf = (Graph) this.graphs.get(i);
						if (cgrf != null && cgrf.name.equals(graphname))
						{
							grf = cgrf;
							break;
						}
					}
				}
				if (grf != null)
				{
					ArrayList aVocab = new ArrayList();
					aVocab.add("<E>");
					HashMap hVocab = new HashMap();
					hVocab.put("<E>", 0);
					grm = grf.compile(iLan, this.gramType, aVocab, hVocab, engine);
					if (grm != null)
					{
						grm.vocab = aVocab;
						hVocab = null;
						grm.prepareForParsing();
					}
					grams.put(grf.name, grm);
				}
				else
				{
					return 0;
				}
			}

			if (nbOfRecursiveCalls(ilabel, RecursiveCalls) > 3)
			{
				return 0;
			}
			RecursiveCalls.add(ilabel);
			int da = debugSyntaxMatch(graphname, graphnode, text, cpos, tunb, textmft, annotations, grm, lengths,
					inputs, variables, outputs, nodes, MatchType.ALL, false, xmltext, RecursiveCalls);
			RecursiveCalls.remove(RecursiveCalls.size() - 1);

			if (da > 0)
			{
				for (int isol = 0; isol < da; isol++)
				{
					// do not touch lengths[isol]
					ArrayList i2 = (ArrayList) inputs.argvalue.get(isol);
					i2.add(0, cpos);
					ArrayList v2 = (ArrayList) variables.argvalue.get(isol);
					v2.add(0, null);
					ArrayList o2 = (ArrayList) outputs.argvalue.get(isol);
					o2.add(0, olabel);
					ArrayList n2 = (ArrayList) nodes.argvalue.get(isol);
					n2.add(0, graphnode);
				}
			}
			return da;
		}
		else
		// simple terminal match
		{
			int da = syntaxMatchTermLabel(ilabel, text, cpos, cposafterspaces, tunb, textmft, annotations, lengths,
					inputs, variables, xmltext);
			if (da > 0)
			{
				// I have computed inputs & variables: I need to add outputs and nodes for sync
				outputs.argvalue = new ArrayList();
				ArrayList o2 = new ArrayList();
				o2.add(olabel);
				nodes.argvalue = new ArrayList();
				ArrayList n2 = new ArrayList();
				n2.add(graphnode);
				for (int isol = 0; isol < da; isol++)
				{
					outputs.argvalue.add(o2);
					nodes.argvalue.add(n2);
				}
			}
			return da;
		}
	}

	private int debugSyntaxMatchSequenceOfLabels(int graphnode, String ilabel, String[] ilabels, String olabel,
			String text, double cpos, double cposafterspaces, int tunb, Mft textmft, ArrayList annotations,
			RefObject<ArrayList> lengths, RefObject<ArrayList> inputs, RefObject<ArrayList> variables,
			RefObject<ArrayList> outputs, RefObject<ArrayList> nodes, boolean xmltext, ArrayList RecursiveCalls)
	{
		lengths.argvalue = null;
		inputs.argvalue = null;
		variables.argvalue = null;
		outputs.argvalue = null;
		nodes.argvalue = null;
		if (!grams.containsKey(ilabel))
		{
			// we need to create a grammar that represents the sequence of ilabels
			Gram grm0 = null;
			ArrayList aVocab = new ArrayList();
			aVocab.add("<E>");
			HashMap hVocab = new HashMap();
			hVocab.put("<E>", 0);
			if (ilabels.length == 1)
			{
				grm0 = new Gram(2);
				grm0.addTransition(0, 1, ilabels[ilabels.length - 1], aVocab, hVocab);
			}
			else
			{
				grm0 = new Gram(ilabels.length + 1);
				int src = 0;
				int dst = 2;
				for (int itok = 0; itok < ilabels.length - 1; itok++)
				{
					grm0.addTransition(src, dst, ilabels[itok], aVocab, hVocab);
					src = dst;
					dst++;
				}
				grm0.addTransition(src, 1, ilabels[ilabels.length - 1], aVocab, hVocab);
			}
			grm0.vocab = aVocab;
			grm0.prepareForParsing();
			grams.put(ilabel, grm0);
		}
		Gram grm = (Gram) grams.get(ilabel);
		if (grm == null)
		{
			// gram did not compile
			return 0;
		}

		if (nbOfRecursiveCalls(ilabel, RecursiveCalls) > 3)
		{
			return 0;
		}
		RecursiveCalls.add(ilabel);
		int da = debugSyntaxMatch(ilabel, graphnode, text, cpos, tunb, textmft, annotations, grm, lengths, inputs,
				variables, outputs, nodes, MatchType.ALL, false, xmltext, RecursiveCalls);
		RecursiveCalls.remove(RecursiveCalls.size() - 1);

		if (da > 0)
		{
			for (int isol = 0; isol < da; isol++)
			{
				// do not touch lengths[isol]
				ArrayList i2 = (ArrayList) inputs.argvalue.get(isol);
				i2.add(0, cpos);
				ArrayList v2 = (ArrayList) variables.argvalue.get(isol);
				v2.add(0, null);
				ArrayList o2 = (ArrayList) outputs.argvalue.get(isol);
				o2.add(0, olabel);
				ArrayList n2 = (ArrayList) nodes.argvalue.get(isol);
				n2.add(0, graphnode);
			}
		}
		return da;
	}

	private int debugSyntaxFailureMatchLabel(int graphnode, String ilabel, String olabel, String text, double cpos,
			double cposafterspaces, int tunb, Mft textmft, ArrayList annotations, RefObject<ArrayList> lengths,
			RefObject<ArrayList> inputs, RefObject<ArrayList> variables, RefObject<ArrayList> outputs,
			RefObject<ArrayList> nodes, boolean xmltext, ArrayList RecursiveCalls, Gram currentgram)
	{
		lengths.argvalue = null;
		inputs.argvalue = null;
		variables.argvalue = null;
		outputs.argvalue = null;
		nodes.argvalue = null;
		if (ilabel.charAt(0) == ':'
				|| (ilabel.charAt(0) == '$' && ilabel.length() >= 2 && ilabel.charAt(1) != '(' && ilabel.charAt(1) != ')')) // recursive
																															// call
		{
			String graphname = ilabel.substring(1);
			Gram grm = null;
			if (!grams.containsKey(graphname))
			{
				// gram :graphname or $graphname does not exist in the grammar: maybe in a variable definition $(var ...
				// $)
				grm = currentgram.getGramFromVariableDefinition(graphname);
				grams.put(graphname, grm);
			}
			else
			{
				grm = (Gram) grams.get(graphname);
			}
			if (grm == null) // not compiled yet
			{
				Graph grf = null;
				if (this.graphs != null)
				{
					for (int i = 0; i < this.graphs.size(); i++)
					{
						Graph cgrf = (Graph) this.graphs.get(i);
						if (cgrf != null && cgrf.name.equals(graphname))
						{
							grf = cgrf;
							break;
						}
					}
				}
				if (grf != null)
				{
					ArrayList aVocab = new ArrayList();
					aVocab.add("<E>");
					HashMap hVocab = new HashMap();
					hVocab.put("<E>", 0);
					grm = grf.compile(iLan, this.gramType, aVocab, hVocab, engine);
					if (grm != null)
					{
						grm.vocab = aVocab;
						hVocab = null;
						grm.prepareForParsing();
					}
					grams.put(grf.name, grm);
				}
				else
				// grf does not even exist
				{
					return 0;
				}
			}

			if (nbOfRecursiveCalls(ilabel, RecursiveCalls) > 3)
			{
				return 0;
			}
			RecursiveCalls.add(ilabel);
			int da = debugSyntaxMatch(graphname, graphnode, text, cpos, tunb, textmft, annotations, grm, lengths,
					inputs, variables, outputs, nodes, MatchType.ALL, false, xmltext, RecursiveCalls);
			RecursiveCalls.remove(RecursiveCalls.size() - 1);

			if (da == 0)
			{
				RecursiveCalls.add(ilabel);
				da = failureDebugSyntaxMatch(graphname, graphnode, text, cpos, tunb, textmft, annotations, grm,
						lengths, inputs, variables, outputs, nodes, MatchType.LONGEST, false, xmltext, RecursiveCalls);
				da = (-1) * da;
				RecursiveCalls.remove(RecursiveCalls.size() - 1);
			}
			if (da != 0) // attention da can be negative
			{
				for (int isol = 0; isol < Math.abs(da); isol++)
				{
					// do not touch lengths[isol]
					ArrayList i2 = (ArrayList) inputs.argvalue.get(isol);
					i2.add(0, cpos);
					ArrayList v2 = (ArrayList) variables.argvalue.get(isol);
					v2.add(0, null);
					ArrayList o2 = (ArrayList) outputs.argvalue.get(isol);
					o2.add(0, olabel);
					ArrayList n2 = (ArrayList) nodes.argvalue.get(isol);
					n2.add(0, graphnode);
				}
			}
			return da;
		}
		else
		// simple terminal match
		{
			int da = syntaxMatchTermLabel(ilabel, text, cpos, cposafterspaces, tunb, textmft, annotations, lengths,
					inputs, variables, xmltext);
			if (da > 0)
			{
				outputs.argvalue = new ArrayList();
				ArrayList o2 = new ArrayList();
				o2.add(olabel);
				nodes.argvalue = new ArrayList();
				ArrayList n2 = new ArrayList();
				n2.add(graphnode);
				for (int isol = 0; isol < da; isol++)
				{
					outputs.argvalue.add(o2);
					nodes.argvalue.add(n2);
				}
			}
			return da;
		}
	}

	private int debugSyntaxFailureMatchSequenceOfLabels(int graphnode, String ilabel, String[] ilabels, String olabel,
			String text, double cpos, double cposafterspaces, int tunb, Mft textmft, ArrayList annotations,
			RefObject<ArrayList> lengths, RefObject<ArrayList> inputs, RefObject<ArrayList> variables,
			RefObject<ArrayList> outputs, RefObject<ArrayList> nodes, boolean xmltext, ArrayList RecursiveCalls)
	{
		lengths.argvalue = null;
		inputs.argvalue = null;
		variables.argvalue = null;
		outputs.argvalue = null;
		nodes.argvalue = null;
		if (!grams.containsKey(ilabel))
		{
			// we need to create a grammar that represents the sequence of ilabels
			Gram grm0 = null;
			ArrayList aVocab = new ArrayList();
			aVocab.add("<E>");
			HashMap hVocab = new HashMap();
			hVocab.put("<E>", 0);
			if (ilabels.length == 1)
			{
				grm0 = new Gram(2);
				grm0.addTransition(0, 1, ilabels[ilabels.length - 1], aVocab, hVocab);
			}
			else
			{
				grm0 = new Gram(ilabels.length + 1);
				int src = 0;
				int dst = 2;
				for (int itok = 0; itok < ilabels.length - 1; itok++)
				{
					grm0.addTransition(src, dst, ilabels[itok], aVocab, hVocab);
					src = dst;
					dst++;
				}
				grm0.addTransition(src, 1, ilabels[ilabels.length - 1], aVocab, hVocab);
			}
			grm0.vocab = aVocab;
			grm0.prepareForParsing();
			grams.put(ilabel, grm0);
		}
		Gram grm = (Gram) grams.get(ilabel);
		if (grm == null)
		{
			// gram did not compile
			return 0;
		}

		RecursiveCalls.add(ilabel);
		int da = debugSyntaxMatch(ilabel, graphnode, text, cpos, tunb, textmft, annotations, grm, lengths, inputs,
				variables, outputs, nodes, MatchType.ALL, false, xmltext, RecursiveCalls);
		RecursiveCalls.remove(RecursiveCalls.size() - 1);

		if (da == 0)
		{
			RecursiveCalls.add(ilabel);
			da = failureDebugSyntaxMatch(ilabel, graphnode, text, cpos, tunb, textmft, annotations, grm, lengths,
					inputs, variables, outputs, nodes, MatchType.LONGEST, false, xmltext, RecursiveCalls);
			da = (-1) * da;
			RecursiveCalls.remove(RecursiveCalls.size() - 1);
		}
		if (da != 0) // attention da can be negative
		{
			for (int isol = 0; isol < Math.abs(da); isol++)
			{
				// do not touch lengths[isol]
				ArrayList i2 = (ArrayList) inputs.argvalue.get(isol);
				i2.add(0, cpos);
				ArrayList v2 = (ArrayList) variables.argvalue.get(isol);
				v2.add(0, null);
				ArrayList o2 = (ArrayList) outputs.argvalue.get(isol);
				o2.add(0, olabel);
				ArrayList n2 = (ArrayList) nodes.argvalue.get(isol);
				n2.add(0, graphnode);
			}
		}
		return da;
	}

	private int nbOfRecursiveCalls(String gname, ArrayList recursivecalls)
	{
		int nb = 0;

		for (String cgname : (ArrayList<String>) recursivecalls)
		{
			if (gname.equals(cgname))
			{
				nb++;
			}
		}
		return nb;
	}

	private boolean alreadyThere(ArrayList lengths, double length, ArrayList positions, ArrayList position,
			ArrayList variables, ArrayList variable, ArrayList outputs, ArrayList output)
	{
		if (lengths == null || lengths.isEmpty())
		{
			return false;
		}
		for (int i = 0; i < lengths.size(); i++)
		{
			double l = (Double) lengths.get(i);
			if (length != l)
			{
				continue;
			}

			ArrayList p = (ArrayList) positions.get(i);
			if ((p == null && position != null) || (p != null && position == null))
			{
				continue;
			}
			if (position != null)
			{
				if (position.size() != p.size())
				{
					continue;
				}
				boolean identical = true;
				for (int j = 0; j < position.size(); j++)
				{
					double cp = (Double) p.get(j);
					double cposition = (Double) position.get(j);
					if (cposition != cp)
					{
						identical = false;
						break;
					}
				}
				if (!identical)
				{
					continue;
				}
			}

			ArrayList v = (ArrayList) variables.get(i);
			if ((v == null && variable != null) || (v != null && variable == null))
			{
				continue;
			}
			if (variable != null)
			{
				if (variable.size() != v.size())
				{
					continue;
				}
				boolean identical = true;
				for (int j = 0; j < variable.size(); j++)
				{
					String cv = (String) v.get(j);
					String cvariable = (String) variable.get(j);
					if (!cv.equals(cvariable))
					{
						identical = false;
						break;
					}
				}
				if (!identical)
				{
					continue;
				}
			}

			ArrayList o = (ArrayList) outputs.get(i);
			if ((o == null && output != null) || (o != null && output == null))
			{
				continue;
			}
			if (output != null)
			{
				if (output.size() != o.size())
				{
					continue;
				}
				boolean identical = true;
				for (int j = 0; j < output.size(); j++)
				{
					String co = (String) o.get(j);
					String coutput = (String) output.get(j);
					if (!co.equals(coutput))
					{
						identical = false;
						break;
					}
				}
				if (!identical)
				{
					continue;
				}
			}
			return true;
		}
		return false;
	}

	private boolean alreadyThereDebug(ArrayList lengths, double length, ArrayList positions, ArrayList position,
			ArrayList variables, ArrayList variable, ArrayList outputs, ArrayList output, ArrayList nodes,
			ArrayList node)
	{
		if (lengths == null || lengths.isEmpty())
		{
			return false;
		}
		for (int i = 0; i < lengths.size(); i++)
		{
			double l = (Double) lengths.get(i);
			if (length != l)
			{
				continue;
			}

			ArrayList p = (ArrayList) positions.get(i);
			if ((p == null && position != null) || (p != null && position == null))
			{
				continue;
			}
			if (position != null)
			{
				if (position.size() != p.size())
				{
					continue;
				}
				boolean identical = true;
				for (int j = 0; j < position.size(); j++)
				{
					double cp = (Double) p.get(j);
					double cposition = (Double) position.get(j);
					if (cposition != cp)
					{
						identical = false;
						break;
					}
				}
				if (!identical)
				{
					continue;
				}
			}

			ArrayList v = (ArrayList) variables.get(i);
			if ((v == null && variable != null) || (v != null && variable == null))
			{
				continue;
			}
			if (variable != null)
			{
				if (variable.size() != v.size())
				{
					continue;
				}
				boolean identical = true;
				for (int j = 0; j < variable.size(); j++)
				{
					String cv = (String) v.get(j);
					String cvariable = (String) variable.get(j);
					if (!cv.equals(cvariable))
					{
						identical = false;
						break;
					}
				}
				if (!identical)
				{
					continue;
				}
			}

			ArrayList o = (ArrayList) outputs.get(i);
			if ((o == null && output != null) || (o != null && output == null))
			{
				continue;
			}
			if (output != null)
			{
				if (output.size() != o.size())
				{
					continue;
				}
				boolean identical = true;
				for (int j = 0; j < output.size(); j++)
				{
					String co = (String) o.get(j);
					String coutput = (String) output.get(j);
					if (!co.equals(coutput))
					{
						identical = false;
						break;
					}
				}
				if (!identical)
				{
					continue;
				}
			}

			ArrayList n = (ArrayList) nodes.get(i);
			if ((n == null && node != null) || (n != null && node == null))
			{
				continue;
			}
			if (node != null)
			{
				if (node.size() != n.size())
				{
					continue;
				}
				boolean identical = true;
				for (int j = 0; j < node.size(); j++)
				{
					if (n.get(j) instanceof Integer)
					{
						int cn = (Integer) n.get(j);
						int cnode = (Integer) node.get(j);
						if (cnode != cn)
						{
							identical = false;
							break;
						}
					}
					else
					{
						String cn = (String) n.get(j);
						if (node.get(j) instanceof Integer)
						{
							identical = false;
							break;
						}
						String cnode = (String) node.get(j);
						if (!cn.equals(cnode))
						{
							identical = false;
							break;
						}
					}
				}
				if (!identical)
				{
					continue;
				}
			}
			return true;
		}
		return false;
	}

	// syntactic parsers

	public final int debugSyntaxMatch(String graphname, int graphnode, String text, double currentpos, int tunb,
			Mft textmft, ArrayList annotations, Gram grm, RefObject<ArrayList> sollengths,
			RefObject<ArrayList> solpositions, RefObject<ArrayList> solvariables, RefObject<ArrayList> soloutputs,
			RefObject<ArrayList> solnodes, MatchType typeofmatch, boolean topcall, boolean xmltext,
			ArrayList RecursiveCalls)
	{
		if (!epsilon.equals("<E>"))
		{
			setConstants();
		}

		sollengths.argvalue = solpositions.argvalue = solvariables.argvalue = soloutputs.argvalue = solnodes.argvalue = null;

		Stack stack = new Stack();
		stack.push(new STrace(currentpos, graphname));
		while (stack.size() > 0)
		{
			STrace curtrc = (STrace) stack.pop();

			State state = (State) grm.states.get(curtrc.Statenb);
			double cpos = curtrc.Pos;
			if (cpos > text.length()) // might happen if after <$>
			{
				continue;
			}
			ArrayList inputs = curtrc.Inputs;
			ArrayList outputs = curtrc.Outputs;
			ArrayList nodes = curtrc.Nodes;
			ArrayList variables = curtrc.Variables;

			double cposafterspaces = cpos;
			RefObject<Double> tempRef_cposafterspaces = new RefObject<Double>(cposafterspaces);
			skipSpaces(text, tempRef_cposafterspaces, xmltext);
			cposafterspaces = tempRef_cposafterspaces.argvalue;
			for (int itrans = 0; itrans < state.Dests.size(); itrans++)
			{
				int dst = (int) state.Dests.get(itrans);
				int lbl = (int) state.IdLabels.get(itrans);

				// check for <ONCE> in output
				String olabel = (String) grm.vocabOut.get(lbl);
				if (olabel != null && olabel.length() > 5 && olabel.substring(0, 5).equals("<ONCE"))
				{
					boolean foundalready = false;
					for (String oz : (ArrayList<String>) outputs)
					{
						if (olabel.equals(oz))
						{
							foundalready = true;
							break;
						}
					}
					if (foundalready)
					{
						continue;
					}
				}

				// check for variable in input, e.g. to recognize <ADV> $ADV in "very very pretty"
				String ilabel0 = (String) grm.vocabIn.get(lbl);
				String[] ilabel;
				boolean avariable = false;
				ilabel = new String[1];
				ilabel[0] = ilabel0;

				for (int ilbl = 0; ilbl < ilabel.length; ilbl++)
				{
					String[] seqlabels = this.iLan.parseSequenceOfTokensAndMetaNodes(ilabel[ilbl]);
					if (seqlabels == null)
					{
						// invalid node complex syntax => skip current label
						continue;
					}
					ArrayList l2 = null, i2 = null, v2 = null, o2 = null, n2 = null;
					int da;
					if (seqlabels == null || !avariable)
					{
						RefObject<ArrayList> tempRef_l2 = new RefObject<ArrayList>(l2);
						RefObject<ArrayList> tempRef_i2 = new RefObject<ArrayList>(i2);
						RefObject<ArrayList> tempRef_v2 = new RefObject<ArrayList>(v2);
						RefObject<ArrayList> tempRef_o2 = new RefObject<ArrayList>(o2);
						RefObject<ArrayList> tempRef_n2 = new RefObject<ArrayList>(n2);
						da = debugSyntaxMatchLabel(state.GraphNodeNumber, ilabel[ilbl], olabel, text, cpos,
								cposafterspaces, tunb, textmft, annotations, tempRef_l2, tempRef_i2, tempRef_v2,
								tempRef_o2, tempRef_n2, xmltext, RecursiveCalls, grm);

						l2 = tempRef_l2.argvalue;
						i2 = tempRef_i2.argvalue;
						v2 = tempRef_v2.argvalue;
						o2 = tempRef_o2.argvalue;
						n2 = tempRef_n2.argvalue;
					}
					else
					{
						RefObject<ArrayList> tempRef_l22 = new RefObject<ArrayList>(l2);
						RefObject<ArrayList> tempRef_i22 = new RefObject<ArrayList>(i2);
						RefObject<ArrayList> tempRef_v22 = new RefObject<ArrayList>(v2);
						RefObject<ArrayList> tempRef_o22 = new RefObject<ArrayList>(o2);
						RefObject<ArrayList> tempRef_n22 = new RefObject<ArrayList>(n2);
						da = debugSyntaxMatchSequenceOfLabels(state.GraphNodeNumber, ilabel[ilbl], seqlabels, olabel,
								text, cpos, cposafterspaces, tunb, textmft, annotations, tempRef_l22, tempRef_i22,
								tempRef_v22, tempRef_o22, tempRef_n22, xmltext, RecursiveCalls);
						l2 = tempRef_l22.argvalue;
						i2 = tempRef_i22.argvalue;
						v2 = tempRef_v22.argvalue;
						o2 = tempRef_o22.argvalue;
						n2 = tempRef_n22.argvalue;
					}
					for (int iamb = 0; iamb < da; iamb++)
					{
						double newpos = cpos;
						if (l2 != null)
						{
							newpos += (Double) l2.get(iamb);
						}

						// compute the new trace and insert it in the stack
						STrace newtrc = new STrace();
						newtrc.Statenb = dst;
						newtrc.Pos = newpos;
						newtrc.Inputs.addAll(inputs);
						newtrc.Variables.addAll(variables);
						newtrc.Outputs.addAll(outputs);
						newtrc.Nodes.addAll(nodes);

						if (i2 != null)
						{
							newtrc.Inputs.addAll((ArrayList) i2.get(iamb));
							newtrc.Variables.addAll((ArrayList) v2.get(iamb));
							newtrc.Outputs.addAll((ArrayList) o2.get(iamb));
							newtrc.Nodes.addAll((ArrayList) n2.get(iamb));
						}

						if (newtrc.Inputs == null || newtrc.Inputs.size() < 1000)
						{
							stack.push(newtrc);
						}
						if (dst == 1) // (bool) grm.IsTerminal[dst])
						{
							double sollength = newpos - currentpos;

							// add terminal state 1 to Nodes and sync the other arrays
							newtrc.Inputs.add(0.0);
							newtrc.Variables.add(null);
							newtrc.Outputs.add(null);
							newtrc.Nodes.add(1); // add terminal state to nodes

							if (sollengths.argvalue == null)
							{
								sollengths.argvalue = new ArrayList();
								solpositions.argvalue = new ArrayList();
								solvariables.argvalue = new ArrayList();
								soloutputs.argvalue = new ArrayList();
								solnodes.argvalue = new ArrayList();

								sollengths.argvalue.add(sollength);
								solpositions.argvalue.add(newtrc.Inputs);
								solvariables.argvalue.add(newtrc.Variables);
								soloutputs.argvalue.add(newtrc.Outputs);
								solnodes.argvalue.add(newtrc.Nodes);
							}
							else if (topcall && typeofmatch == MatchType.LONGEST) // longest
							{
								if (sollength > (Double) sollengths.argvalue.get(0))
								{
									sollengths.argvalue.set(0, sollength);
									solpositions.argvalue.set(0, newtrc.Inputs);
									solvariables.argvalue.set(0, newtrc.Variables);
									soloutputs.argvalue.set(0, newtrc.Outputs);
									solnodes.argvalue.set(0, newtrc.Nodes);
									int size = sollengths.argvalue.size() - 1;
									if (size > 0)
									{
										sollengths.argvalue.subList(1, size + 1).clear();
										solpositions.argvalue.subList(1, size + 1).clear();
										solvariables.argvalue.subList(1, size + 1).clear();
										soloutputs.argvalue.subList(1, size + 1).clear();
										solnodes.argvalue.subList(1, size + 1).clear();
									}
								}
								else if (sollength == (Double) sollengths.argvalue.get(0))
								{
									sollengths.argvalue.add(sollength);
									solpositions.argvalue.add(newtrc.Inputs);
									solvariables.argvalue.add(newtrc.Variables);
									soloutputs.argvalue.add(newtrc.Outputs);
									solnodes.argvalue.add(newtrc.Nodes);
								}
								continue;
							}
							else
							// all matches
							{
								// if (!alreadythere(sollengths, sollength, solpositions, newtrc.Inputs, solvariables,
								// newtrc.Variables, soloutputs, newtrc.Outputs))
								{
									sollengths.argvalue.add(sollength);
									solpositions.argvalue.add(newtrc.Inputs);
									solvariables.argvalue.add(newtrc.Variables);
									soloutputs.argvalue.add(newtrc.Outputs);
									solnodes.argvalue.add(newtrc.Nodes);
								}
							}
						}
					}
				}
			}
		}
		if (sollengths.argvalue == null)
		{
			return 0;
		}
		else
		{
			return sollengths.argvalue.size();
		}
	}

	private final int failureDebugSyntaxMatch(String graphname, int graphnode, String text, double currentpos, int tunb,
			Mft textmft, ArrayList annotations, Gram grm, RefObject<ArrayList> sollengths,
			RefObject<ArrayList> solpositions, RefObject<ArrayList> solvariables, RefObject<ArrayList> soloutputs,
			RefObject<ArrayList> solnodes, MatchType typeofmatch, boolean topcall, boolean xmltext,
			ArrayList RecursiveCalls)
	{
		if (!epsilon.equals("<E>"))
		{
			setConstants();
		}

		sollengths.argvalue = solpositions.argvalue = solvariables.argvalue = soloutputs.argvalue = solnodes.argvalue = null;
		Stack stack = new Stack();
		stack.push(new STrace(currentpos, graphname));
		while (stack.size() > 0)
		{
			STrace curtrc = (STrace) stack.pop();

			State state = (State) grm.states.get(curtrc.Statenb);
			double cpos = curtrc.Pos;
			ArrayList inputs = curtrc.Inputs;
			ArrayList outputs = curtrc.Outputs;
			ArrayList nodes = curtrc.Nodes;
			ArrayList variables = curtrc.Variables;

			double cposafterspaces = cpos;
			RefObject<Double> tempRef_cposafterspaces = new RefObject<Double>(cposafterspaces);
			skipSpaces(text, tempRef_cposafterspaces, xmltext);
			cposafterspaces = tempRef_cposafterspaces.argvalue;
			for (int itrans = 0; itrans < state.Dests.size(); itrans++)
			{
				int dst = (int) state.Dests.get(itrans);
				int lbl = (int) state.IdLabels.get(itrans);

				// check for <ONCE> in output
				String olabel = (String) grm.vocabOut.get(lbl);
				if (olabel != null && olabel.length() > 5 && olabel.substring(0, 5).equals("<ONCE"))
				{
					boolean foundalready = false;
					for (String oz : (ArrayList<String>) outputs)
					{
						if (olabel.equals(oz))
						{
							foundalready = true;
							break;
						}
					}
					if (foundalready)
					{
						continue;
					}
				}

				// check for variable in input, e.g. to recognize <ADV> $ADV in "very very pretty"
				String ilabel0 = (String) grm.vocabIn.get(lbl);
				String[] ilabel;
				boolean avariable = false;
				ilabel = new String[1];
				ilabel[0] = ilabel0;

				for (int ilbl = 0; ilbl < ilabel.length; ilbl++)
				{
					String[] seqlabels = this.iLan.parseSequenceOfTokensAndMetaNodes(ilabel[ilbl]);
					if (seqlabels == null)
					{
						// invalid node complex syntax => skip
						continue;
					}
					ArrayList l2 = null, i2 = null, v2 = null, o2 = null, n2 = null;
					int da;
					if (seqlabels == null || !avariable)
					{
						RefObject<ArrayList> tempRef_l2 = new RefObject<ArrayList>(l2);
						RefObject<ArrayList> tempRef_i2 = new RefObject<ArrayList>(i2);
						RefObject<ArrayList> tempRef_v2 = new RefObject<ArrayList>(v2);
						RefObject<ArrayList> tempRef_o2 = new RefObject<ArrayList>(o2);
						RefObject<ArrayList> tempRef_n2 = new RefObject<ArrayList>(n2);
						da = debugSyntaxFailureMatchLabel(state.GraphNodeNumber, ilabel[ilbl], olabel, text, cpos,
								cposafterspaces, tunb, textmft, annotations, tempRef_l2, tempRef_i2, tempRef_v2,
								tempRef_o2, tempRef_n2, xmltext, RecursiveCalls, grm);

						l2 = tempRef_l2.argvalue;
						i2 = tempRef_i2.argvalue;
						v2 = tempRef_v2.argvalue;
						o2 = tempRef_o2.argvalue;
						n2 = tempRef_n2.argvalue;
					}

					else
					{
						RefObject<ArrayList> tempRef_l22 = new RefObject<ArrayList>(l2);
						RefObject<ArrayList> tempRef_i22 = new RefObject<ArrayList>(i2);
						RefObject<ArrayList> tempRef_v22 = new RefObject<ArrayList>(v2);
						RefObject<ArrayList> tempRef_o22 = new RefObject<ArrayList>(o2);
						RefObject<ArrayList> tempRef_n22 = new RefObject<ArrayList>(n2);
						da = debugSyntaxFailureMatchSequenceOfLabels(state.GraphNodeNumber, ilabel[ilbl], seqlabels,
								olabel, text, cpos, cposafterspaces, tunb, textmft, annotations, tempRef_l22,
								tempRef_i22, tempRef_v22, tempRef_o22, tempRef_n22, xmltext, RecursiveCalls);
						l2 = tempRef_l22.argvalue;
						i2 = tempRef_i22.argvalue;
						v2 = tempRef_v22.argvalue;
						o2 = tempRef_o22.argvalue;
						n2 = tempRef_n22.argvalue;
					}

					for (int iamb = 0; iamb < Math.abs(da); iamb++)
					{
						double newpos = cpos;
						if (l2 != null)
						{
							newpos += (Double) l2.get(iamb);
						}

						// compute the new trace and insert it in the stack
						STrace newtrc = new STrace();
						newtrc.Statenb = dst;
						newtrc.Pos = newpos;
						newtrc.Inputs.addAll(inputs);
						newtrc.Variables.addAll(variables);
						newtrc.Outputs.addAll(outputs);
						newtrc.Nodes.addAll(nodes);

						if (i2 != null)
						{
							newtrc.Inputs.addAll((ArrayList) i2.get(iamb));
							newtrc.Variables.addAll((ArrayList) v2.get(iamb));
							newtrc.Outputs.addAll((ArrayList) o2.get(iamb));
							newtrc.Nodes.addAll((ArrayList) n2.get(iamb));
						}
						if (dst == 1 && da > 0) // (bool) grm.IsTerminal[dst])
						{
							// add terminal state to nodes and sync with other arrays
							newtrc.Inputs.add(cpos);
							newtrc.Variables.add(null);
							newtrc.Outputs.add(null);
							newtrc.Nodes.add(1);
						}

						if (da > 0 && (newtrc.Inputs == null || newtrc.Inputs.size() < 1000))
						{
							stack.push(newtrc);
						}
						double sollength = newpos - currentpos;

						if (sollengths.argvalue == null)
						{
							sollengths.argvalue = new ArrayList();
							solpositions.argvalue = new ArrayList();
							solvariables.argvalue = new ArrayList();
							soloutputs.argvalue = new ArrayList();
							solnodes.argvalue = new ArrayList();

							sollengths.argvalue.add(sollength);
							solpositions.argvalue.add(newtrc.Inputs);
							solvariables.argvalue.add(newtrc.Variables);
							soloutputs.argvalue.add(newtrc.Outputs);
							solnodes.argvalue.add(newtrc.Nodes);
						}
						else if (typeofmatch == MatchType.LONGEST) // longest
						{
							if (sollength > (Double) sollengths.argvalue.get(0)
									|| ((ArrayList) newtrc.Nodes).size() > ((ArrayList) solnodes.argvalue.get(0))
											.size())
							{
								sollengths.argvalue.set(0, sollength);
								solpositions.argvalue.set(0, newtrc.Inputs);
								solvariables.argvalue.set(0, newtrc.Variables);
								soloutputs.argvalue.set(0, newtrc.Outputs);
								solnodes.argvalue.set(0, newtrc.Nodes);
								int size = sollengths.argvalue.size() - 1;
								if (size > 0)
								{
									sollengths.argvalue.subList(1, size + 1).clear();
									solpositions.argvalue.subList(1, size + 1).clear();
									solvariables.argvalue.subList(1, size + 1).clear();
									soloutputs.argvalue.subList(1, size + 1).clear();
									solnodes.argvalue.subList(1, size + 1).clear();
								}
							}
							else if (sollength == (Double) sollengths.argvalue.get(0))
							{
								if (!alreadyThereDebug(sollengths.argvalue, sollength, solpositions.argvalue,
										newtrc.Inputs, solvariables.argvalue, newtrc.Variables, soloutputs.argvalue,
										newtrc.Outputs, solnodes.argvalue, newtrc.Nodes))
								{
									sollengths.argvalue.add(sollength);
									solpositions.argvalue.add(newtrc.Inputs);
									solvariables.argvalue.add(newtrc.Variables);
									soloutputs.argvalue.add(newtrc.Outputs);
									solnodes.argvalue.add(newtrc.Nodes);
								}
							}
							continue;
						}
						else
						// all matches
						{
							if (!alreadyThere(sollengths.argvalue, sollength, solpositions.argvalue, newtrc.Inputs,
									solvariables.argvalue, newtrc.Variables, soloutputs.argvalue, newtrc.Outputs))
							{
								sollengths.argvalue.add(sollength);
								solpositions.argvalue.add(newtrc.Inputs);
								solvariables.argvalue.add(newtrc.Variables);
								soloutputs.argvalue.add(newtrc.Outputs);
								solnodes.argvalue.add(newtrc.Nodes);
							}
						}
					}
				}
			}
		}
		if (sollengths.argvalue == null)
		{
			return 0;
		}
		else
		{
			return sollengths.argvalue.size();
		}
	}

	public ArrayList getExtraParams()
	{
		return extraParams;
	}

	public void setExtraParams(ArrayList extraParams)
	{
		this.extraParams = extraParams;
	}
}